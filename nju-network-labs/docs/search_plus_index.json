{"./":{"url":"./","title":"Computer Network Lab Manual","keywords":"","body":"Computer Network Lab Manual Computer Network, Nanjing University, Spring 2020 Course Info Course Number: 22010050 Lecturer: Chen Tian & Wenzhong Li Website: https://cs.nju.edu.cn/lwz/networks-2020/ Contact Course QQ group: 940577165 You can find TAs and our 教学立方 invitation code after joining this group. [!TIP] You may have many questions about our labs. There are some questions can be answered in our manual, some can be answered by searching the Internet, and some we have not mentioned which need to be added to our manual. We welcome the third one because the answers to the first two questions are readily available. To give you faster access to the answers, you need to take a look at this article 提问的智慧. Lab Assignments Lab 1: Switchyard & Mininet Out: 2020-3-4, due 2020-3-18. Start the lab here Lab 2: Learning Switch Out: 2020-3-11, due 2020-3-25. Start the lab here IPv4 Router Introduction to Labs 3 to 5 Lab 3: Respond to ARP Out: 2020-3-25, due 2020-4-8. Start the lab here Lab 4: Forwarding packets Out: 2020-4-8, due 2020-4-22. Start the lab here Lab 5: Respond to ICMP Out: 2020-4-22, due 2020-5-6. Start the lab here Lab 6: Reliable Communication Out: 2020-5-6, due 2020-5-27. Start the lab here Lab 7: Firewall Out: 2020-5-27, due 2020-6-17. Start the lab here Policies We encourage discussions with others to clarify questions about homework problems and programming assignment problem statements. However [!DANGER|style:flat] Programming solutions must be your own. Do not make your remote assignment repository public. "},"content/ch01/lab-1.html":{"url":"content/ch01/lab-1.html","title":"Lab 1: Switchyard & Mininet","keywords":"","body":"Lab 1: Switchyard & Mininet Overview In this chapter we will introduce all preparations for our network experiments. Then your are going to modify the examples we provide according to our requirements. Details Our lab assignments are based on CS640 in University of Wisconsin. Most materials are the same. In the future, we will improve the experiment based on your feedback. In this lab assignment, you will gradually master our experimental environment. But some preliminary abilities are required in our experiments such as how to program and debug in Linux. If you are not familiar with these, feel free to contact TAs. We will provide you with some helpful information to get started quickly. Platform The platform of our labs is Switchyard. You can implement a device with various functions in Switchyard by writing Python codes. Then you can run your device in Mininet and capture packets using Wireshark. You will use Git to manage your projects and submit them. All these software are installed on Linux. We recommend using Visual Studio Code as your editor. Here is the list of softwares we mentioned (sorted by learning order). Linux Python Git Mininet Wireshark Switchyard VS Code Your Tasks [!NOTE] The sentences marked with ✅ are related to the content of your report. Please pay attention. Task 1: Get Ready Meet the requirements for using Linux, Python and Git. We assume that you have a basic understanding of these contents. Start your task here Task 2: An Example Meet the requirements for using Mininet, Wireshark and Switchyard. At the meantime you will learn how to complete this assignment. Start your task here Task 3: NJU GitLab Sign up on NJU GitLab and prepare for submission. Start your task here [!DANGER] Do not skip this task. We use NJU GitLab to collect your projects. Task 4: Your Modification After Task 1 2 3, you are ready to do some exercises on our platform and count 4. Start your task here Handing it in Report We will provide a template of your lab assignment report here. You need to submit the report in your repository named _lab_1. The format of your report can be Microsoft Doc or PDF. An example is 123456789拾佰仟_lab_1.pdf. Capture file The capture file's name should be lab_1.pcapng or lab_1.pcap. If you capture packets using superuser, you may meet some problems. Read the tips below. [!WARNING] You may (or as I expect you must) meet the error when you try to modify/delete the files generated by Wireshark or Switchyard programs running on hosts in Mininet. It is because the owner of these files is superuser root. You need to change the owner to your login user. Run the command below on your capture file. Replace to the file path of your capture file. $ sudo chown $USER:$USER Another useful command ls -l can check if the owner of the file is root. You can see the file belonging to root is test.log in the example. (syenv) cyq@cyq-VirtualBox:~/switchyard$ ls -l total 88 -rw-rw-r-- 1 cyq cyq 35147 2月 20 17:33 COPYING -rw-rw-r-- 1 cyq cyq 427 2月 20 17:33 Dockerfile drwxrwxr-x 6 cyq cyq 4096 2月 20 17:33 docs drwxrwxr-x 3 cyq cyq 4096 2月 20 17:33 documentation drwxrwxr-x 4 cyq cyq 4096 2月 21 00:01 examples -rw-rw-r-- 1 cyq cyq 5119 2月 20 17:33 README.rst -rw-rw-r-- 1 cyq cyq 144 2月 20 17:33 requirements.txt -rwxrwxr-x 1 cyq cyq 405 2月 20 17:33 runtests.sh -rw-rw-r-- 1 cyq cyq 2266 2月 20 17:33 setup.py drwxrwxr-x 4 cyq cyq 4096 2月 20 17:33 switchyard drwxrwxr-x 6 cyq cyq 4096 2月 20 17:37 syenv -rw-r--r-- 1 root root 181 2月 21 21:42 lab_1.pcap drwxrwxr-x 2 cyq cyq 4096 2月 20 17:33 tests In this case, running the command sudo chown $USER:$USER ./lab_1.pcap can change the owner to my user cyq. As we mentioned before, be careful when using sudo since it may have potential risks. Submit to NJU GitLab When you are ready to submit, do the following. Modify your code according to Task 3, complete your report and save your capture file. When you have done your work, put your report, code and capture file in the folder lab_1 and commit them. Tag the commit named which you want to submit. An example is 123456789/lab_1. For more about tag, read Git 基础 - 打标签. Finally your project will look like switchyard/ ├─docs/ ├─.../ m ├─lab_1/ + │ ├─123456789拾佰仟_lab_1.pdf m │ ├─hubtests.py + │ ├─lab_1.pcapng m │ ├─myhub.py m │ └─start_mininet.py ├─.gitignore └─... [!WARNING] The file names in your submission have to exactly match the file names above. Otherwise, you will lose points! Submit your work by pushing your local repository to your remote repository with your tags by running the command git push origin --tags. [!WARNING] Only commit your source code to your local repository. If there are some generated files that are not source code, ignore them by adding them in the file .gitignore. "},"content/ch01/prerequisites.html":{"url":"content/ch01/prerequisites.html","title":"Task 1: Prerequisites","keywords":"","body":"Task 1: Prerequisites There are three things you need to know. The operating system we use is Linux. The program language we use is Python. And the distributed version control system we use is Git. We list some helpful materials below. Linux Python Git In further experiments, we assume that you have mastered the use of these tools. "},"content/ch01/linux.html":{"url":"content/ch01/linux.html","title":"Linux","keywords":"","body":"Linux The operating system of our experimental environment is Ubuntu 18.04 which is a free and open-source Linux distribution. In order to run Linux, you need to install a virtual machine hypervisor on your computer. There are two reasons. Our experiments involve changes to the network. Using a virtual machine (VM) can avoid impact on your computer. We will introduce Mininet and Switchyard later. It is much more easier to install and run them on Linux. [!NOTE] You are also free to use your favorite virtualization software for the lab assignment but you will most probably have to deal with the possible issues on yourself. Install VirtualBox First download the VirtualBox installer, you can find it here. You can choose the latest VirtualBox installer. If the operating system of your host is Windows, then click the download link \"Windows hosts\". Another tool you need to download is \"Extension Pack\" which allows you resize your Linux display in VirtualBox. We highlight them in the picture below. After completing download, install VirtualBox first then the extension pack. Import the VM Image To ensure that your experimental environment is consistent, we provide a VM image. This image has Switchyard, Mininet and Wireshark installed so you do not need to worry about setting up the environment. You can find the VM image here. User name: njucs Password: 123 You can learn about importing a VM image in VirtualBox here. Install the Extension in VM Start your VM and check if your Linux runs well. You will find the display size is fixed to 800×600. To resize it you need to install the VirtualBox extension pack into your VM. You can learn about installing the extension at here. Use Linux Most of our operations will be completed inside the terminal. You need to know Power on & off File system operations File and User permissions Run programs A tutorial of Linux can be found at 鸟哥的 Linux 私房菜 —— 基础学习篇. Select the part you want to know and read it. I Don't Like Your VM If you are a free soul and want to setup Switchyard in a different environment you are welcome to do that as well. You can find some useful information here. This might or might not be useful for you depending on your environment. "},"content/ch01/python.html":{"url":"content/ch01/python.html","title":"Python","keywords":"","body":"Python Switchyard and Mininet are developed in Python. So you need to program in Python (though there are some methods to avoid using Python). Python is an easy-learning language. If you are not familiar with it, here are some materials for you to get started. 廖雪峰的 Python 3 教程 Python 教程 Learn Python - Free Interactive Python Tutorial Our VM is Python preinstalled (both version 2 and 3) so you can skip installing. Topics you need to know about Python are listed here: Python Interpreter Data Types (Important) Data Structures (Important) Flow Control (Important) Functions (Important) Modules Input and Output Errors and Exceptions Standard Library Virtual Environments and Packages (Important) Except those topics marked as important, it is no need to read it carefully, just program as you learn. We expect that you will cost about 3 days on this if you haven't worked with Python. [!NOTE] Python 3 is the main language you will use in Switchyard programming. But you need to know some difference between Python 3 and Python 2 though they are mostly the same. Because you may write some Mininet topology scripts using Python 2. In our VM, you need to type python3 to start Python 3 and python to start Python 2. "},"content/ch01/git.html":{"url":"content/ch01/git.html","title":"Git","keywords":"","body":"Git You can use Git to manage your projects with a clear editing history and we recommend using it. It is better to have your local repository synchronized with a remote backup on GitHub or some one else. The tutorial of Git is listed below. 廖雪峰的 Git 教程 We expect that you will cost 2 days on this. Then please sign up on NJU GitLab. You will submit your codes on it. "},"content/ch01/workflow.html":{"url":"content/ch01/workflow.html","title":"Task 2: Workflow","keywords":"","body":"Task 2: Workflow Our experiment requires Mininet to build a network. You will use Switchyard to run your network device. Wireshark is used to capture packets. And you may use Visual Studio Code to develope your projects. Here are four sections to introduce them and we ask you to read these sections carefully. This will affect your later experiments. You will see an example of the network hub, a network hardware device for connecting multiple Ethernet devices together and making them act as a single network segment. It has multiple input/output (I/O) ports, in which a signal introduced at the input of any port appears at the output of every port except the original incoming. A hub works at the physical layer (layer 1) of the OSI model. In short, hub allows devices to communicate with each other. Here you don't need to understand the working principle of hub. VS Code Mininet Wireshark Switchyard "},"content/ch01/vscode.html":{"url":"content/ch01/vscode.html","title":"VS Code","keywords":"","body":"VS Code You can use Visual Studio Code (VSC) to develope your projects. I will show how to install it and introduce some plugins may help you. This tutorial is prepared for those who want to take full control of Switchyard in one editor. We use Ubuntu 18.04 here. As we have provided the VM image with VSC preinstalled, you can skip the installation. We expect that you will spend several hours on this. Install VSC You can choose the VM image with VSC preinstalled. But someone like to install it themselves. The easiest way to install Visual Studio Code for Debian/Ubuntu based distributions is to download and install the .deb package (64-bit), either through the graphical software center if it's available, or through the command line with: $ sudo apt install ./.deb Develope Switchyard with VSC [!TIP] Here we will get in touch with Switchyard in advance. You can just skim the content of Switchyard now. After reading the section Switchyard, come back again. Open the folder of Switchyard in VSC. You can open files in the explorer and edit them. Then there are some plugins you may want to install. For Python, check this extension and install it. Next open any Python files and you will see a pop-up message ask you whether you want to install a linter. Pylint is enough to use so install it. You have got almost every thing you need here. But you may what to format your document by right click on your editor and choose \"Format Document\". VSC will tell you that you need to install a formatter. Yapf is better for me but you are free to use others. Debug Switchyard with VSC Switchyard document about debug shows that you are free to choose other debuggers. Let's replace pbd with VSC debugger. This will works when running in Switchyard test environment. For VSC, you need to create debugging configuration. The example next shows how to debug examples/myhub.py with examples/hubtests.py. Set break point in your code and click the configuration to debug. Run Switchyard This part is not VSC integrated, you need to run Switchyard in the terminal. Read the section Switchyard for more. "},"content/ch01/mininet.html":{"url":"content/ch01/mininet.html","title":"Mininet","keywords":"","body":"Mininet Mininet enables you to quickly create, interact with, customize and share a software defined network prototype, and provides a smooth path to running on hardware. The most useful material is their website. Here is the Mininet Walkthrough. At this stage you will encounter some concepts you are not familiar with such as switches and hosts, but remember to come back after you have learned them. In this section, we will have a small practice of Mininet. [!NOTE] Ignore the content about switches like Open vSwitch (OVS) setting up. We expect that you will spend 2 days on this. Install Mininet If you find that Mininet is not installed on your system, run this command to install it. $ sudo apt-get install mininet Or you want to build mininet yourself. The installation guide is here. Install Xterm If you find that Xterm is not installed on your system, run this command to install it. $ sudo apt-get install xterm Everyday Mininet Usage First, a (perhaps obvious) note on command syntax for this walkthrough: $ proceeds Linux commands that should be typed at the shell prompt mininet> proceeds Mininet commands that should be typed at Mininet’s CLI, # proceeds Linux commands that are typed at a root shell prompt Start Mininet So let's start with Mininet startup options. Type the following command to display a help message. Read the output for more usages of Mininet. $ sudo mn -h [!WARNING|style:flat] Commands start with sudo or run as a superuser (prompt like #) are dangerous. Avoid doing things like that. But you need run Mininet as a superuser so be careful. Then let's build a Mininet default topology. $ sudo mn You will see the same output as the picture above. See what Mininet tells us. The default topology contains two hosts and one switch. They link like this h1 --- s1 --- h2 And you now are in Mininet CLI starts with mininet>. The next thing is to interact with Hosts. Keep this open and let's go to the next subsection. Interact with Hosts First let's see what we can do in Mininet CLI. mininet> help Display nodes. mininet > nodes Display links. mininet> net Dump information about all nodes. This command is useful. mininet> dump You should see the switch and two hosts listed. If the first string typed into the Mininet CLI is a host, switch or controller name, the command is executed on that node. Run a command on a host process. mininet> h1 ifconfig -a And you can start a pop-up terminal emulator in one host. mininet> h1 xterm The new window pops up here is the terminal emulator of h1. If you type ifconfig -a here, the output is totally the same as you type h1 ifconfig -a in Mininet CLI. Test Connectivity Between Hosts Now, verify that you can ping from host 0 to host 1. You can also do it in pop-up xterm at h1. You will learn what ping is in the later lessons. Now ping just tells you whether two hosts is well-connected. mininet> h1 ping -c 1 h2 An easier way to run this test is to use the Mininet CLI built-in pingall command, which does an all-pairs ping. mininet> pingall Run A Simple Web Server and Client Remember that ping isn’t the only command you can run on a host! Mininet hosts can run any command or application that is available to the underlying Linux system (or VM) and its file system. You can also enter any bash command, including job control (&, jobs, kill, etc..) Next, try starting a simple HTTP server on h1, making a request from h2, then shutting down the web server. mininet> h1 python -m SimpleHTTPServer 80 & mininet> h2 wget -O - h1 ... mininet> h1 kill %python Exit the CLI. mininet> exit Cleanup If Mininet crashes for some reason, clean it up. $ sudo mn -c Custom Topologies Custom topologies can be easily defined as well, using a simple Python API. The example here connects 4 devices as a star topology shows below. This file is in the Switchyard repository examples/start_mininet.py. #!/usr/bin/python import sys from mininet.topo import Topo from mininet.net import Mininet from mininet.log import lg from mininet.node import CPULimitedHost from mininet.link import TCLink from mininet.util import irange, custom, quietRun, dumpNetConnections from mininet.cli import CLI from time import sleep, time from subprocess import Popen, PIPE import subprocess import argparse import os parser = argparse.ArgumentParser(description=\"Mininet pyswitch topology\") # no arguments needed as yet :-) args = parser.parse_args() lg.setLogLevel('info') class PySwitchTopo(Topo): def __init__(self, args): # Add default members to class. super(PySwitchTopo, self).__init__() # Host and link configuration # # # server1 # \\ # hub----client # / # server2 # nodeconfig = {'cpu':-1} self.addHost('server1', **nodeconfig) self.addHost('server2', **nodeconfig) self.addHost('hub', **nodeconfig) self.addHost('client', **nodeconfig) for node in ['server1','server2','client']: # all links are 10Mb/s, 100 millisecond prop delay self.addLink(node, 'hub', bw=10, delay='100ms') def set_ip(net, node1, node2, ip): node1 = net.get(node1) ilist = node1.connectionsTo(net.get(node2)) # returns list of tuples intf = ilist[0] intf[0].setIP(ip) def reset_macs(net, node, macbase): ifnum = 1 node_object = net.get(node) for intf in node_object.intfList(): node_object.setMAC(macbase.format(ifnum), intf) ifnum += 1 for intf in node_object.intfList(): print node,intf,node_object.MAC(intf) def set_route(net, fromnode, prefix, nextnode): node_object = net.get(fromnode) ilist = node_object.connectionsTo(net.get(nextnode)) node_object.setDefaultRoute(ilist[0][0]) def setup_addressing(net): reset_macs(net, 'server1', '10:00:00:00:00:{:02x}') reset_macs(net, 'server2', '20:00:00:00:00:{:02x}') reset_macs(net, 'client', '30:00:00:00:00:{:02x}') reset_macs(net, 'hub', '40:00:00:00:00:{:02x}') set_ip(net, 'server1','hub','192.168.100.1/24') set_ip(net, 'server2','hub','192.168.100.2/24') set_ip(net, 'client','hub','192.168.100.3/24') def disable_ipv6(net): for v in net.values(): v.cmdPrint('sysctl -w net.ipv6.conf.all.disable_ipv6=1') v.cmdPrint('sysctl -w net.ipv6.conf.default.disable_ipv6=1') def main(): topo = PySwitchTopo(args) net = Mininet(controller=None, topo=topo, link=TCLink, cleanup=True) setup_addressing(net) disable_ipv6(net) net.interact() if __name__ == '__main__': main() We build a topology inside the constructor function __init__ of class PySwitchTopo. If you want to change the topology, you should modify it. We setup interfaces in the function setup_addressing, you will learn what happens here after knowing Ethernet and IP protocol. In general, you don't need to modify the topology file we provide. But if you do, you need the document Introduction to Mininet which gives you the Mininet Python API. Please read it carefully. Then let's start this topology. $ sudo python examples/start_mininet.py In this topology, hosts can not ping each other because the device named hub has no routing rules configured, so exit here. In the section of Switchyard, we will make it work. [!NOTE] Mininet topology scripts are written in Python 2. "},"content/ch01/wireshark.html":{"url":"content/ch01/wireshark.html","title":"Wireshark","keywords":"","body":"How to use Wireshark Wireshark is the world’s foremost and widely-used network protocol analyzer. It lets you see what’s happening on your network at a microscopic level and is the de facto (and often de jure) standard across many commercial and non-profit enterprises, government agencies, and educational institutions. You will use it to inspect your network setting up by Mininet, and test the function of your device written in Switchyard. We also have a small practice of Wireshark in our manual. Wireshark User’s Guide is a verbose document about Wireshark but We do not recommend it. So sometimes the official document is hard for user to get started. You can find many blogs writing about how to use Wireshark. Read them instead or the first search result in Google here. We expect that this will cost you an afternoon. Install Wireshark If you find that Wireshark is not installed on your system, run these commands to install it. $ sudo add-apt-repository ppa:wireshark-dev/stable $ sudo apt-get update $ sudo apt-get install wireshark You need to configure wireshark during installation. For non-superusers capturing packets, choose Yes here. Then add your user to wireshark user group to allow you capturing packets. $ sudo usermod -a -G wireshark $USER Capturing Packets First start the default Mininet topology. $ sudo mn Then open wireshark in h1. mininet> h1 wireshark & You need to choose which traffic you want to capture. Packets will send and receive on h1-eth0 so you double click it. It will be empty or some ICMPv6 packets be captured. Let's make some traffic ourselves. mininet> h1 ping -c 1 h2 So here we have more packets captured. You may not know why these packets show up, but you will learned in the next few lessons. Now let's filter some packets by typing protocol name on the filter text box. You can also check the field in the packets like ethernet source MAC address. The value will be highlighted both in packet details and packet raw bytes. "},"content/ch01/switchyard.html":{"url":"content/ch01/switchyard.html","title":"Switchyard","keywords":"","body":"How to program in Switchyard Switchyard is a framework for creating, testing, and experimenting with software implementations of networked systems such as Ethernet switches, IP routers, firewalls and middleboxes, and end-host protocol stacks. It is the framework targeting on teaching and used in University of Wisconsin. So we have this framework to do some network testing without multiple devices and a bunch of wires. Switchyard documentation is available here. And this is the document you read most often. In this section we will combine Mininet, Wireshark and Switchyard together. We expect that you have complete How to use Mininet and How to use Wireshark. Next is to learn how to program in Switchyard. We will show you a hub, just forward any input packets to any other interfaces. There are three files for this section. examples/start_mininet.py examples/myhub.py examples/hubtests.py The Switchyard documentation also uses these files to show many useful APIs. Again, this document is very important. You need to read it whenever you get confused with the APIs or Switchyard itself. In this section we do not show you the APIs but the workflow and a little code explanation. We expect that it will take you up to 4 days on this. It may be a little bit tricky. But this is important. Install Switchyard You can find instructions here, the repository of Switchyard on Gitee. A quick note here for Ubuntu. If you can't find the folder switchyard in your home dictionary, you need to get the source code of Switchyard. $ git clone https://gitee.com/shellqiqi/switchyard.git Then you need to get some dependent softwares and libraries. $ sudo apt-get install libffi-dev libpcap-dev python3-dev python3-pip You can install Switchyard and the necessary related packages in an isolated Python virtual environment (\"venv\"), which is the recommended path, or in the system directories, which is often less desirable. The venv route is highly suggested, since it makes all installation \"local\" and can easily destroyed, cleaned up, and recreated. To create a new virtual environment, you could do something like the following under your workspace folder switchyard. $ python3 -m venv syenv [!WARNING] Many students create their virtual environment under ~ so there is a folder ~/syenv, which is WRONG. The right path is ~/switchyard/syenv. After this command, you will find a folder syenv in switchyard, which is the folder of the Python virtual environment. You can change the name syenv to whatever you'd like to name your virtual environment. Next, you need to activate the environment. The instructions vary depending on the shell you're using. On bash, the command is $ source ./syenv/bin/activate Exactly, activate is a runnable file in the folder syenv. You'll need to replace syenv with whatever you named the virtual environment. If you're using a different shell than bash, refer to Python documentation on the venv module. Finally, install Switchyard. All the required additional libraries should be automatically installed, too. $ python3 -m pip install switchyard Then I suggest to exclude your virtual environment out of git tracking. Add this line in .gitignore if there is not. syenv/ Prepare Your Test Script Writing tests to determine whether a piece of code behaves as expected is an important part of the software development process. With Switchyard, it is possible to create a set of tests that verify whether a program attempts to receive packets when it should and sends the right packet(s) out the right ports. A test scenario is Switchyard’s term for a series of tests that verify a program’s behavior. A test scenario is simply a Python source code file that includes a particular variable name (symbol) called scenario, which must refer to an instance of the class TestScenario. A TestScenario object contains the basic configuration for an imaginary network device along with an ordered series of test expectations. These expectations may be one of three types: that a particular packet should arrive on a particular interface/port, that a particular packet should be emitted out one or more ports, and that the user program should time out when calling recv_packet because no packets are available. To start off, here is an example of an empty test scenario: from switchyard.lib.userlib import * scenario = TestScenario(\"test example\") For more about writing tests, you need to read Test Scenario Creation. In later lab assignments, you need to construct test script yourself. But this time we have a template test script helps you. Here is the test script for our hub. #!/usr/bin/env python3 from switchyard.lib.userlib import * def mk_pkt(hwsrc, hwdst, ipsrc, ipdst, reply=False): ether = Ethernet(src=hwsrc, dst=hwdst, ethertype=EtherType.IP) ippkt = IPv4(src=ipsrc, dst=ipdst, protocol=IPProtocol.ICMP, ttl=32) icmppkt = ICMP() if reply: icmppkt.icmptype = ICMPType.EchoReply else: icmppkt.icmptype = ICMPType.EchoRequest return ether + ippkt + icmppkt def hub_tests(): s = TestScenario(\"hub tests\") s.add_interface('eth0', '10:00:00:00:00:01') s.add_interface('eth1', '10:00:00:00:00:02') s.add_interface('eth2', '10:00:00:00:00:03') # test case 1: a frame with broadcast destination should get sent out # all ports except ingress testpkt = mk_pkt(\"30:00:00:00:00:02\", \"ff:ff:ff:ff:ff:ff\", \"172.16.42.2\", \"255.255.255.255\") s.expect(PacketInputEvent(\"eth1\", testpkt, display=Ethernet), \"An Ethernet frame with a broadcast destination address should arrive on eth1\") s.expect(PacketOutputEvent(\"eth0\", testpkt, \"eth2\", testpkt, display=Ethernet), \"The Ethernet frame with a broadcast destination address should be forwarded out ports eth0 and eth2\") # test case 2: a frame with any unicast address except one assigned to hub # interface should be sent out all ports except ingress reqpkt = mk_pkt(\"20:00:00:00:00:01\", \"30:00:00:00:00:02\", '192.168.1.100','172.16.42.2') s.expect(PacketInputEvent(\"eth0\", reqpkt, display=Ethernet), \"An Ethernet frame from 20:00:00:00:00:01 to 30:00:00:00:00:02 should arrive on eth0\") s.expect(PacketOutputEvent(\"eth1\", reqpkt, \"eth2\", reqpkt, display=Ethernet), \"Ethernet frame destined for 30:00:00:00:00:02 should be flooded out eth1 and eth2\") resppkt = mk_pkt(\"30:00:00:00:00:02\", \"20:00:00:00:00:01\", '172.16.42.2', '192.168.1.100', reply=True) s.expect(PacketInputEvent(\"eth1\", resppkt, display=Ethernet), \"An Ethernet frame from 30:00:00:00:00:02 to 20:00:00:00:00:01 should arrive on eth1\") s.expect(PacketOutputEvent(\"eth0\", resppkt, \"eth2\", resppkt, display=Ethernet), \"Ethernet frame destined to 20:00:00:00:00:01 should be flooded out eth0 and eth2\") # test case 3: a frame with dest address of one of the interfaces should # result in nothing happening reqpkt = mk_pkt(\"20:00:00:00:00:01\", \"10:00:00:00:00:03\", '192.168.1.100','172.16.42.2') s.expect(PacketInputEvent(\"eth2\", reqpkt, display=Ethernet), \"An Ethernet frame should arrive on eth2 with destination address the same as eth2's MAC address\") s.expect(PacketInputTimeoutEvent(1.0), \"The hub should not do anything in response to a frame arriving with a destination address referring to the hub itself.\") return s scenario = hub_tests() The function mk_pkt is used to make a packet. For now you don't need to know what the parameters means. The function hub_tests returns a TestScenario object which assigned to scenario. The var scenario is very important in the test framework of Switchyard, do not forget it. We construct the scenario with a name \"hub tests\". Then we add three interfaces with name and MAC address on our hub. In every case, we make a packet then feed it into one interface of our hub with PacketInputEvent. Then we compare the outgoing packets from interfaces of our hub with our expectation packets using PacketOutputEvent. If there is no packet out, we use the function PacketInputTimeoutEvent to check there is no traffic for a period of time. All test APIs used is introduced here. You may want to run this test, we will cover this later. Implement your device Switchyard is the framework enables you to implement a device. A Switchyard program is simply a Python program that includes a particular entry point function which accepts a single parameter. The startup function can simply be named main, but can also be named switchy_main if you like. The function must accept at least one parameter, which is a reference to the Switchyard network object (described below). Method calls on the network object are used to send and receive packets to and from network ports. A Switchyard program isn’t executed directly with the Python interpreter. Instead, the program swyard is used to start up the Switchyard framework and to load your code. When Switchyard starts your code it looks for a function named main and invokes it, passing in the network object as the first parameter. Details on how to start Switchyard (and thus your program) are given in the chapters on running a Switchyard in the test environment and running Switchyard in a live environment. Note that it is possible to pass arguments into a Switchyard program; see Passing arguments into a Switchyard program for details. A Switchyard program will typically also import other Switchyard modules such as modules for parsing and constructing packets, dealing with network addresses, and other functions. These modules are introduced below and described in detail in the API reference chapter. In the later lab assignments, you need to implement your device. Generally, your initial test files and device logic are not complete. You need to modify them step by step. This programming mode is called Test Driven Development (TDD). Here is our hub code. #!/usr/bin/env python3 ''' Ethernet hub in Switchyard. ''' from switchyard.lib.userlib import * def main(net): my_interfaces = net.interfaces() mymacs = [intf.ethaddr for intf in my_interfaces] while True: try: timestamp,dev,packet = net.recv_packet() except NoPackets: continue except Shutdown: return log_debug (\"In {} received packet {} on {}\".format(net.name, packet, dev)) eth = packet.get_header(Ethernet) if eth is None: log_info(\"Received a non-Ethernet packet?!\") continue if eth.dst in mymacs: log_info (\"Received a packet intended for me\") else: for intf in my_interfaces: if dev != intf.name: log_info (\"Flooding packet {} to {}\".format(packet, intf.name)) net.send_packet(intf, packet) net.shutdown() In Switchyard, the device you want to be the hub will run this script and act like a hub by receiving any packets and forwarding to any other interfaces except the packets towards the hub itself. The APIs used in this file is introduced here. Running in the Test Environment [!NOTE|style:flat] You need to activate your Python virtual environment first in any case you want to run Switchyard. This step is very important. In the root dictionary of Switchyard, run $ source ./syenv/bin/activate You can test your hub code with your test file in Switchyard test mode. At minimum you would invoke swyard as follows. $ swyard -t examples/hubtests.py examples/myhub.py Note that the -t option puts swyard in test mode. The argument to the -t option should be the name of the test scenario to be executed, and the final argument is the name of your code. After that, you will get some output shows if your tests pass or fail. More about test environment and some debug methods are introduced here. Running in the Mininet In the test environment, here is no true traffic here. The device only take the packets we provided. We need to challenge the true networking. Here we have Mininet can construct a network. First let's start our topology we provided at examples/start_mininet.py. $ sudo python examples/start_mininet.py Then run your hub code to the device you what. Here must be the root of our star shape topology named hub. It is better to open xterm on it so you can see the output of it. mininet> xterm hub Then run your hub code on it. Remember activate your Python virtual environment first. Replace to the path of Switchyard. # source /syenv/bin/activate # swyard examples/myhub.py ... here is your hub logs ... Now you have your topology ready and your hub running, let's see if it works. In Mininet CLI, type pingall and return. mininet> pingall *** Ping: testing ping reachability client -> X server1 server2 hub -> X X X server1 -> client X server2 server2 -> client X server1 *** Results: 50% dropped (6/12 received) This is the output what you will see. You are able to capture in Mininet too. In any host you want to capture packets, run wireshark on it. In our case, we run wireshark on the host named client. Then we ping client to server1. mininet> client wireshark & mininet> client ping -c1 server1 "},"content/ch01/nju-gitlab.html":{"url":"content/ch01/nju-gitlab.html","title":"Task 3: NJU GitLab","keywords":"","body":"Task 3: NJU GitLab To submit your work, you need to do the following things at the first time: Sign up on https://git.nju.edu.cn with your own NJU email account. Sign in. Import the repository https://git.nju.edu.cn/njucn-2020-spring/switchyard to your own account and make it private, then you will get your own repository url. Here is a brief guide in one picture about how to import the project. Don't fork because that makes your repository public. Share your repository with us. Find \"Members\" in \"Settings\" of your repository. In \"Invite group\", select njucn-2020-spring/student/ and make us as \"Reporter\" or \"Developer\". [!NOTE|style:flat] Please fill out the form in the QQ group file GitLab 私有仓库地址提交 first. After we collect them, we will inform you of the invitation. There is a directory ~/switchyard in your virtual machine (if you use the VM image we provide). Set the remote repository of switchyard to your repository url by running the command git remote set-url origin . Otherwise, clone your own remote repository. "},"content/ch01/modification.html":{"url":"content/ch01/modification.html","title":"Task 4: Modification","keywords":"","body":"Task 3: Modification Preparation Let's start with our example files. Create a directory named lab_1 in ~/switchyard. Your should start by copying the template files examples/start_mininet.py, examples/myhub.py and examples/hubtests.py into lab_1. And your project will look like switchyard/ ├─docs/ ├─.../ + ├─lab_1/ + │ ├─hubtests.py + │ ├─myhub.py + │ └─start_mininet.py ├─.gitignore └─... Play the Tutorial Again You have done the tutorial. However it is necessary to work by yourself. So modify our examples files. [!TIP] We suggest that you can commit in Git when you complete one step. [!WARNING] All of your modifications should be done on the files under your directory lab_1. We will check and compare the git commits to judge the originality of your work. So remember to commit every time you complete one small task. Step 1: Modify the Mininet topology In the section Mininet, we introduced how to construct a topology. So here we have two options for you, choose one to implement. ✅ Then show the details of how you build the topology in your report. Delete server2 in the topology, Or create a different topology containing 6 nodes using hosts and hubs (don't use other kinds of devices). The file you need to modify is lab_1/start_mininet.py. Step 2: Modify the logic of a device In the section Switchyard, we introduced how to program a device. Your task is to count how many packets pass through a hub in and out. You need to log the statistical result every time you receive one packet with the format of each line in: out:. For example, if there is a packet that is not addressed to the hub itself, then the hub may log in:1 out:2. ✅ Then show the log of your hub when running it in Mininet and how you implement it in your report. [!NOTE] In the old version we need you to print the timestamp then we remove it. So many students ask why because there is a function log_info which prints the time of log output. However we want you to log the packet arrival time which is different from output time. Because our explanation is late, if you have implemented it in another way, you do not need to change. The file you need to modify is lab_1/myhub.py. Step 3: Modify the test scenario of a device In the section Switchyard, we introduced how to write the test case. So here we have two options for you, choose one to implement. ✅ Then show the details of your test cases in your report. Create one test case by using the given function mk_pkt with different arguments, Or create one test case with your handmade packet. The file you need to modify is lab_1/hubtests.py. Step 4: Run your device in Mininet In the section Switchyard, we introduced how to run Switchyard programs in Mininet. So run your new hub in your new topology and make sure it works. ✅ Show the procedure in your report. Step 5: Capture using Wireshark Both in section Wireshark and Switchyard, we introduced how to capture packets. In your own topology, capture packets on one host (no hub) while creating some traffic. Save your capture file and submit it with your report and code. ✅ Also you need to describe the details of your capture file. "},"content/ch02/lab-2.html":{"url":"content/ch02/lab-2.html","title":"Lab 2: Learning Switch","keywords":"","body":"Lab 2: Learning Switch Overview In this assignment, you are going to implement the core functionalities of an Ethernet learning switch using the Switchyard framework. An Ethernet switch is a layer 2 device that uses packet switching to receive, process and forward frames to other devices (end hosts, other switches) in the network. A switch has a set of interfaces (ports) through which it sends/receives Ethernet frames. When Ethernet frames arrive on any port, the switch process the header of the frame to obtain information about the destination host. If the switch knows that the host is reachable through one of its ports, it sends out the frame from the appropriate output port. If it does not know where the host is, it floods the frame out of all ports except the input port. Details Your task is to implement the logic of a switch. As it is described in the last paragraph of the \"Ethernet Learning Switch Operation\" section, your switch will also handle the frames that are intended for itself and the frames whose Ethernet destination address is the broadcast address FF:FF:FF:FF:FF:FF. In addition to these, you will also implement three different mechanisms to purge the outdated/stale entries from the forwarding table. This will allow your learning switch to adapt to changes in the network topology. These mechanisms are: Remove an entry from the forwarding table after 10 seconds have elapsed. Remove the least recently used (LRU) entry from the forwarding table. For this functionality assume that your table can only hold 5 entries at a time. If a new entry comes and your table is full, you will remove the entry that has not been matched with a Ethernet frame destination address for the longest time. Remove the entry that has the least traffic volume. For this functionality assume that your table can only hold 5 entries at a time. Traffic volume for an entry is the number of frames that the switch received where Destination MAC address == MAC address of entry. You will implement these mechanisms in three separate Python files. The core functionalities that are explained above will be the same for these implementations. [!WARNING] Please carefully read the FAQ section, for more specific details regarding the implementations Your Tasks In these tasks, you will write the code to implement the core logic in an Ethernet learning switch using the Switchyard framework. Besides using Switchyard for developing and testing your switch, you can deploy it in Mininet to test it in a \"live\" setting. The code you'll need to add for the simplest version of this exercise should be less than 20 lines (and possibly quite a bit less depending on exactly how you write the code). There are extensions to the basic learning switch that could add quite a bit more code. [!NOTE] The sentences marked with ✅ are related to the content of your report. Please pay attention. Task 1: Preparation Initiate your project with our template. Start the task here Task 2: Basic Learning Switch Start with the basic learning switch. Start the task here Task 3: Timeouts Implement timeouts based on the previous task. Start the task here Task 4: LRU Rule Replacement Algorithm Implement LRU rule replacement algorithm based on Task 2. Start the task here Task 5: Least Traffic Volume Rule Replacement Algorithm Implement least traffic volume rule replacement algorithm based on Task 2. Start the task here Handing it in Report We will provide a template of your lab assignment report here. You need to submit the report in your repository named _lab_2. The format of your report can be Microsoft Doc or PDF. An example is 123456789拾佰仟_lab_2.pdf. Submit to NJU GitLab To submit your work, you need to do the following things. Modify your code and complete your report. When you have done your work, put your report and code in the folder lab_2 then commit them. Tag the commit named which you want to submit. An example is 123456789/lab_2. Finally your project will look like switchyard/ ├─docs/ ├─.../ m ├─lab_2/ + │ ├─123456789拾佰仟_lab_2.pdf m │ ├─myswitch.py m │ ├─myswitch_to.py m │ ├─myswitch_lru.py m │ ├─myswitch_traffic.py │ ├─... m │ └─start_mininet.py ├─.gitignore └─... [!WARNING] The file names in your submission have to exactly match the file names above. Otherwise, you will lose points! Submit your work by pushing your local repository to your remote repository with your tags by running the command git push origin --tags. [!WARNING] Only commit your source code to your local repository. If there are some generated files that are not source code, ignore them by adding them in the file .gitignore. "},"content/ch02/preparation.html":{"url":"content/ch02/preparation.html","title":"Task 1: Preparation","keywords":"","body":"Task 1: Preparation There is an example of a switch without learning implemented in switchyard/examples/exercises/learning_switch/myswitch.py. Let's start with it. Create a directory named lab_2 in switchyard. Copy examples/exercises/learning_switch/switchtopo.py to lab_2/start_mininet.py. Make 4 copies of examples/exercises/learning_switch/myswitch.py to: lab_2/myswitch.py: Your basic learning switch. lab_2/myswitch_to.py: Your learning switch with timeout based entry removal. lab_2/myswitch_lru.py: Your learning switch with LRU based entry removal. lab_2/myswitch_traffic.py: Your learning switch with traffic volume based entry removal. (Optional) Create your test files in lab_2. lab_2/mytests.py: Your test file of lab_2/myswitch.py. lab_2/mytests_to.py: Your test file of lab_2/myswitch_to.py. lab_2/mytests_lru.py: Your test file of lab_2/myswitch_lru.py. lab_2/mytests_traffic.py: Your test file of lab_2/myswitch_traffic.py. Though we will provide the test files, they are incomprehensible. So you should still write test scenarios that test all aspects of your code. You can find our test files below. Download it and you will use it to test your switch later. You can unzip the test files we provide into the folder lab_2. Download compiled test cases here. Finally, your project will look like switchyard ├─docs/ ├─.../ + ├─lab_2/ + │ ├─myswitch.py + │ ├─myswitch_to.py + │ ├─myswitch_lru.py + │ ├─myswitch_traffic.py │ ├─... + │ └─start_mininet.py ├─.gitignore └─... [!WARNING] All of your modifications should be done on the files under your directory lab_2. We will check and compare the git commits to judge the originality of your work. So remember to commit every time you complete one small task. "},"content/ch02/basic-switch.html":{"url":"content/ch02/basic-switch.html","title":"Task 2: Basic Switch","keywords":"","body":"Task 2: Basic Switch Ethernet Learning Switch Operation An Ethernet learning switch is a device that has a set of interfaces (\"ports\") with links connected to other switches, and to end hosts. When Ethernet frames arrive on any port/interface, the switch sends the frame on an appropriate output port if the switch knows that the host is reachable through that port, or floods the frame out all ports if it does not know where the host is. Consider the picture below. Say that Switch 1 doesn't know the locations of any host on the network, and that H1 wants to send an Ethernet frame to H3. When that frame arrives at Switch 1, it sees Ethernet source address 00:00:00:00:00:01 and destination address 00:00:00:00:00:03. From this packet arrival, it knows that it can now reach H1 by send a frame out the same interface on which this frame has arrived. However, it does not know where to send to frame to reach H3, so it floods the packet out all ports except the one on which the frame arrived. Eventually, H3 will receive the frame. If it replies to H1, Switch 1 will receive a frame with the source address as H3's address, and the frame will arrive on the interface connected to Switch 2. At this point, Switch 1 now knows exactly which ports it needs to use to send frames to either H1 or H3. The following flowchart summarizes the example described above. The only additional considerations shown in the flowchart are if the destination address is the same as one of the Ethernet addresses on the switch itself (i.e., the frame is intended for the switch), or the Ethernet destination address is the broadcast address FF:FF:FF:FF:FF:FF. Your switch may have a table like: MAC Address Interface ab:cd:ef:fe:cd:ba interface-0 ... ... Coding Your task is to implement the logic in the above flowchart, using the Switchyard framework. The starter file is named lab_2/myswitch.py, which is the only file you'll need to modify. Some links to Switchyard API documentation which you may find helpful are: Packet Parsing/Construction Introduction Packet Parsing/Construction Reference Ethernet Packet Header Reference Note that the documentation of Switchyard has examples on running Switchyard in test mode and in real mode, along with a walkthrough of creating a simple hub device, which is useful background material for this exercise. Testing You can test your basic learning switch yourself. No test results need to show in your report. Deploying To run your switch in Mininet, run the lab_2/start_mininet.py custom topology script. It will create a small network consisting of a single switch with three hosts (client, server1, and server2) in the following configuration. To start up Mininet using this script, just type: $ sudo python lab_2/start_mininet.py Once Mininet starts up, you should open a terminal window on the Mininet node named \"switch\": mininet> xterm switch In the window that opens (xterm on the node \"switch\"), activate venv and run your switch in \"real\" (non-test) mode: (syenv) # swyard myswitch.py [!NOTE] Note that to run swyard in Mininet in a root shell (such as the shell that is open in response to the xterm command), you will need to activate the Python virtual environment which has Switchyard installed in it. Refer to the Switchyard documentation for more information. To examine whether your switch is behaving correctly, you can do the following: Open terminals on client, server1 and server2 (xterm client, xterm server1 and xterm server2 from the Mininet prompt) In the server1 and server2 terminal, run wireshark. Wireshark is a program that allows you to \"snoop\" on network traffic arriving on a network interface. We'll use this to verify that we see packets arriving at server1 and server2 from client. In the terminal on the client node, type ping -c 2 192.168.100.1. This command will send two \"echo\" requests to the server1 node. The server1 node should respond to each of them if your switch is working correctly. You should see at the two echo request and echo replies in Wireshark running on server1, and you will probably see a couple other packets (e.g., ARP, or Address Resolution Protocol, packets). If you run Wireshark on server2, you should not see the echo request and reply packets (but you will see the ARP packets, since they are sent with broadcast destination addresses). ✅ Analyze and state the results of the above process in your report with screenshots. Do not explain how you do step by step but focus on the switch's forwarding logic. "},"content/ch02/timeouts.html":{"url":"content/ch02/timeouts.html","title":"Task 3: Timeouts","keywords":"","body":"Task 3: Timeouts Timeout Mechanism Real learning switches remove forwarding table entries after some number of seconds have elapsed so that a learning switch can adapt to changes in network topology. Implement a timeout feature in your learning switch. Choose some reasonable value for a timeout (e.g., 10 seconds). The following flowchart summarizes the algorithm described above. Your switch may have a table like: MAC Address Interface Timestamp ab:cd:ef:fe:cd:ba interface-0 123456.123456 ... ... ... Coding Your task is to implement the logic in the above flowchart, using the Switchyard framework. You can start with copying the content of lab_2/myswitch.py to lab_2/myswitch_to.py, which is the only file you'll need to modify. Testing You should first develop your switch code using the Switchyard test framework. Assuming you have installed Switchyard in a Python virtual environment and have activated that venv, you should run: (syenv) $ swyard -t lab_2/switchtests_to.srpy lab_2/myswitch_to.py The above command it will execute a series of test cases against your program and display whether the tests pass or fail. The file switchtests_to.srpy is the test file we provide. ✅ In the report, show the test result of your switch.(Optional) If you have written the test files yourself, show how you test the timeout mechanism. Once you get the tests to pass, you can try running your code in Mininet. Deploying Run your switch in Mininet. ✅ In Mininet, test your timeout mechanism. Prove that the timeout mechanism works with your testing procedure in the report. "},"content/ch02/lru.html":{"url":"content/ch02/lru.html","title":"Task 4: Least Recently Used","keywords":"","body":"Task 4: Least Recently Used Implementing Limited Storage for Rules Learned Real learning switches also have limited storage for forwarding rules that are learned. Implement a feature by which your learning switch can only hold a limited number of rules (implement this flexibly so that you can easily change the maximum number of rules). When your switch needs to add a new rule but there is no more space, you can consider different policies for evicting an existing rule. This time we evict the least recently used rule. General implementations of this technique require keeping \"age bits\" for rules and track the \"Least Recently Used\" rule based on age-bits. In such an implementation, every time a rule is used, the age of all other rules changes. For this functionality assume that your table can only hold 5 entries at a time. If a new entry comes and your table is full, you will remove the entry that has not been matched with a Ethernet frame destination address for the longest time. The following flowchart summarizes the algorithm described above. Your switch may have a table like: MAC Address Interface Age ab:cd:ef:fe:cd:ba interface-0 2 ... ... ... Coding Your task is to implement the logic in the above flowchart, using the Switchyard framework. You can start with copying the content of lab_2/myswitch.py to lab_2/myswitch_lru.py, which is the only file you'll need to modify. Testing Test your switch with the test file switchtests_lru.srpy we provide. ✅ In the report, show the test result of your switch.(Optional) If you have written the test files yourself, show how you test the LRU algorithm. Deploying Run your switch in Mininet. ✅ In Mininet, test the LRU algorithm. Prove that the LRU algorithm works with your testing procedure in the report. "},"content/ch02/ltv.html":{"url":"content/ch02/ltv.html","title":"Task 5: Least Traffic Volume","keywords":"","body":"Task 5: Least Traffic Volume Another Limited Storage for Rules Learned When your switch needs to add a new rule but there is no more space, we can evict the rule that has observed the least amount of network traffic in terms of numbers of packets. In addition, how you count network traffic can be done in different ways: you could also consider number of bytes, or number of application payload bytes (ignoring bytes from lower layer headers). For this functionality assume that your table can only hold 5 entries at a time. Traffic volume for an entry is the number of packets that the switch received where Destination MAC address == MAC address of entry. The following flowchart summarizes the algorithm described above. Your switch may have a table like: MAC Address Interface Traffic Volume ab:cd:ef:fe:cd:ba interface-0 15 ... ... ... Coding Your task is to implement the logic in the above flowchart, using the Switchyard framework. You can start with copying the content of lab_2/myswitch.py to lab_2/myswitch_traffic.py, which is the only file you'll need to modify. Testing Test your switch with the test file switchtests_traffic.srpy we provide. ✅ In the report, show the test result of your switch.(Optional) If you have written the test files yourself, show how you test the least traffic volume algorithm. Deploying Run your switch in Mininet. ✅ In Mininet, test the least traffic volume algorithm. Prove that the least traffic volume algorithm works with your testing procedure in the report. "},"content/ch02/faq.html":{"url":"content/ch02/faq.html","title":"FAQ","keywords":"","body":"FAQ Q: Let's assume that the table in my switch has 5 entries: [h2, h3, h4, h5, h1] where h2 is the entry that has not been matched the longest while h1 is the most recently matched entry. If a new packet (src=h6, dest=h2) arrives, how is my switch supposed to handle this packet in the LRU-based entry removal implementation (assuming that the network topology does not change)? A: Whenever you receive a new packet, you will assess the state of the switch as if you don't know about the new packet and make decisions accordingly. So when your switch receives (h6, h2), it is going to add an entry for h6 since it is not in the table. However, since the table is full (5 entries) it will need to remove the LRU entry, which is h2. So your table is going to look like this: [h3, h4, h5, h1, h6] and your switch will broadcast the incoming packets on all ports except for the incoming port since it does not have information about h2 anymore. In other words, your switch (upon receiving the packet) is not going to update the table to [h3, h4, h5, h1, h2], remove h3 and add h6 to get [h4, h5, h1, h6, h2] and output the packet on a single port, which goes to h2. Q: How do the entry removal mechanisms work? A: Note that the flow chart for timeout based mechanism does not show when/how to purge the stale entries. Your implementation will obviously handle this as well. Keep in mind that there is not a limit on the number of entries that the table can hold for this mechanism. Q: How would the table look for the following sequence of packets in the LRU-based implementation: (h1,h4), (h2,h1), (h3,h1), (h4,h1), (h5,h1), (h6.h7), (h4,h5)? (assuming that the network topology does not change) A: Assuming that the leftmost entry is the most recently used and the rightmost is the least recently used: [h1] → [h1, h2] → [h1, h3, h2] → [h1, h4, h3, h2] → [h1, h5, h4, h3, h2] → [h6, h1, h5, h4, h3] → [h5, h6, h1, h4, h3] Q: Should our switch implementations be aware of changes in the topology? A: Your learning switch has to be aware of the changes in the topology. More specifically, if the switch receives a packet from host A on its interface 1 (i1) it will record this in its table {a → i1}. Later, if the switch receives another packet from host A but on a different interface (say i2), and if the entry {a → i1} is still present, it will be updated to {a → i2}. There will not be two different entries for the same host in your table! Reflecting the topological changes in your implementations will differ slightly: Timeout-based: When updating the entry for a particular host, reset its timer to 0 (this will be equivalent to refreshing the entry for that host). LRU-based: When updating the entry for a particular host, do not update its LRU information. Traffic volume-based: When updating the entry for a particular host, keep the same traffic volume count for the host. Do not set it to 0. Q: In traffic volume based entry removal, which entry should be removed if there are two entries with the lowest traffic volume? A: You can pick an entry randomly. "},"content/ch03/ipv4-router.html":{"url":"content/ch03/ipv4-router.html","title":"Lab 3-5: IPv4 Router","keywords":"","body":"IPv4 Router Overview Now that you have built a simple learning Ethernet switch and feel more comfortable with the Switchyard framework, you will get to do even more cool stuff using it. In these assignment from lab 3 to lab 5, you are going to complete a series of tasks to eventually create a fully functional IPv4 router. At a high level, your router will have the following capabilities: Responding to/Making ARP requests Receiving packets and forwarding them to their destination by using a lookup table Responding to/Generating ICMP messages Details In order to create this cool router with the aforementioned capabilities, you will implement 5 main functionalities: Respond to ARP (Address Resolution Protocol) requests for addresses that are assigned to interfaces on the router. Make ARP requests for IP addresses that have no known Ethernet MAC address. A router will often have to send packets to other hosts, and needs Ethernet MAC addresses to do so. Receive and forward packets that arrive on links and are destined to other hosts. Part of the forwarding process is to perform address lookups (\"longest prefix match\" lookups) in the forwarding information base. You will eventually just use \"static\" routing in your router, rather than implement a dynamic routing protocol like RIP or OSPF. Respond to Internet Control Message Protocol (ICMP) messages like echo requests (\"pings\"). Generate ICMP error messages when necessary, such as when an IP packet's TTL (time to live) value has been decremented to zero. You can find more detailed information on these functionalities in the following lab assignments: Lab 3: Complete Item #1. Lab 4: Complete Item #2 and Item #3. Lab 5: Complete Item #4 and Item #5. Notes Address Resolution Protocol (ARP) Review ARP is a protocol used for resolving IP addresses to MAC addresses. The main issue is that although IP addresses are used to forward IP packets across networks, a link-level address of the host or router to which you want to send the packet is required in a particular physical network. Therefore, hosts in the network need to keep a mapping between IP and link-layer addresses. Hosts can use ARP to broadcast query messages for a particular IP address in their physical networks so that the appropriate host can reply this query with its link-layer address. Internet Control Message Protocol (ICMP) Review ICMP is one of the main protocols that allows routers to closely monitor the operation of the Internet. ICMP messages are used by network devices (e.g routers) for sending error messages to indicate various issues, such as unreachable destination host/network or expired TTL for a packet. ping is a very commonly used network administration utility that uses ICMP Echo Request/Reply packets to validate the reachability of a host and also collect information about the status of the network (e.g average RTT, % of packet loss, etc.). Testing Your Code Just like the previous assignment, you should test the correctness of your implementation by writing your own test cases. As your friendly TA, I should warn you that in this assignment you will be implementing more functionalities and your router will be handling more events concurrently compared to the previous assignment. Therefore, you should think about reasonable ways to test the correctness of your implementation. One thing you can do is create test separate test cases that only tests certain functionalities. This will allow you to see whether the individual parts of your router is working properly. Then, you can generate larger test cases to make sure that the separate modules work together properly without breaking each other. As always, do not forget to consider corner cases. Helpful Materials Switchyard API Documentation Switchyard Test Scenario Creation "},"content/ch03/subch01/lab-3.html":{"url":"content/ch03/subch01/lab-3.html","title":"Lab 3: Respond to ARP","keywords":"","body":"Lab 3: Respond to ARP Overview This is the first in a series of exercises that have the ultimate goal of creating an IPv4 router. The basic functions of an Internet router are to: Respond to ARP (Address Resolution Protocol) requests for addresses that are assigned to interfaces on the router. Make ARP requests for IP addresses that have no known Ethernet MAC address. A router will often have to send packets to other hosts, and needs Ethernet MAC addresses to do so. Receive and forward packets that arrive on links and are destined to other hosts. Part of the forwarding process is to perform address lookups (\"longest prefix match\" lookups) in the forwarding information base. You will eventually just use \"static\" routing in your router, rather than implement a dynamic routing protocol like RIP or OSPF. Respond to Internet Control Message Protocol (ICMP) messages like echo requests (\"pings\"). Generate ICMP error messages when necessary, such as when an IP packet's TTL (time to live) value has been decremented to zero. The goal of this first stage of building the router is to accomplish item #1 above: respond to ARP requests. Your Tasks In the source directory for this exercise, there is a Python file to use as a starter template: myrouter.py. This file contains the outline of a Router class, and currently contains a constructor (__init__) method and a router_main method. This is just a starter template: you can refactor and redesign the code in any way you like. The main task for this exercise is to modify the Router class to do the following: [!NOTE] The sentences marked with ✅ are related to the content of your report. Please pay attention. Task 1: Preparation Initiate your project with our template. Start the task here Task 2: Handle ARP Requests Ready to make ARP work. Start the task here Task 3: Cached ARP Table Maintain a correlation between each MAC address and its corresponding IP address. Start the task here Handing it in Report We will provide a template of your lab assignment report here. You need to submit the report in your repository named _lab_3. The format of your report can be Microsoft Doc or PDF. An example is 123456789拾佰仟_lab_3.pdf. Submit to NJU GitLab To submit your work, you need to do the following things. Modify your code and complete your report. When you have done your work, put your report and code in the folder lab_3 then commit them. Tag the commit named which you want to submit. An example is 123456789/lab_3. Finally your project will look like switchyard ├─docs/ ├─.../ + ├─lab_3/ + │ ├─123456789拾佰仟_lab_3.pdf + │ ├─myrouter.py │ ├─... + │ └─start_mininet.py ├─.gitignore └─... [!WARNING] The file names in your submission have to exactly match the file names above. Otherwise, you will lose points! Submit your work by pushing your local repository to your remote repository with your tags by running the command git push origin --tags. [!WARNING] Only commit your source code and other necessary files to your local repository. If some generated files are not source code, ignore them by adding them in the file .gitignore. "},"content/ch03/subch01/preparation.html":{"url":"content/ch03/subch01/preparation.html","title":"Task 1: Preparation","keywords":"","body":"Preparation There is an example of a router without anything implemented in switchyard/examples/exercises/router/myrouter.py. Let's start with it. Create a directory named lab_3 in switchyard. Copy examples/exercises/router/start_mininet.py to lab_3/start_mininet.py. Copy examples/exercises/router/myrouter.py to lab_3/myrouter.py. Though we will provide the test files, they are incomprehensible. So you should still write test scenarios that test all aspects of your code. You can find our test files below. Download it and you will use it to test your router later. You can unzip the test files we provide into the folder lab_3. Download compiled test cases here. Finally, your project will look like switchyard ├─docs/ ├─.../ + ├─lab_3/ + │ ├─myrouter.py │ ├─... + │ └─start_mininet.py ├─.gitignore └─... [!WARNING] All of your modifications should be done on the files under your directory lab_3. We will check and compare the git commits to judge the originality of your work. So remember to commit every time you complete one small task. "},"content/ch03/subch01/handle-arp-request.html":{"url":"content/ch03/subch01/handle-arp-request.html","title":"Task 2: Handle ARP Request","keywords":"","body":"Task 2: Handle ARP Requests Procedure Upon receiving a packet, determine whether it is an ARP request. Received ARP Requests For ARP packet headers, there are two types of addresses, as well as source and destination values for each address type, giving a total of four addresses. For an ARP request, the source Ethernet and IP addresses are filled in, as well as the destination IP address. Note that the source and destination IP addresses are called senderprotoaddr and targetprotoaddr in the ARP header, respectively. The source and destination Ethernet addresses are called senderhwaddr and targethwaddr, respectively. The destination Ethernet address is not filled in: this is the address being requested. Note that the packet header class for ARP is named Arp, so to obtain the ARP header from an incoming packet (if it exists) you can do something like: arp = packet.get_header(Arp) See the Arp packet header reference in the Switchyard documentation for more. For each ARP request, you should determine whether the targetprotoaddr field (IP address destination) in the ARP header is an IP address assigned to one of the interfaces on your router. Remember that you can get a list of interfaces configured for the router by calling the interfaces method (or equivalently, the ports method) on the net object stored in the self.net attribute in the Router class. Note also that you can look up ports by Ethernet address, by name, or by IP address; refer to the documentation for the appropriate method. If the destination IP address is one that is assigned to an interface of your Router, you should create and send an appropriate ARP reply. (If the destination IP address is not assigned to one of the router's interfaces, you should not respond with an ARP reply, even if you have enough information to do so.) The ARP reply should be sent out the same interface on which the ARP request arrived. [!TIP] The Switchyard documentation has details on what is returned by the interfaces method. You may wish to call this method in the constructor of the Router class and create some internal data structure for the Router, so it can keep track of its own interfaces. Received Other Packets If a packet that you receive in the router is not an ARP request, you should ignore it (drop it) for now. In future exercises you'll handle more incoming packet types in your router. Coding Your task is to implement the logic described above. The start file is named lab_3/myrouter.py. The Switchyard documentation contains a section introducing how Packet parsing and construction works. This is strongly recommended background reading. You will also probably find the API reference to be helpful for packet parsing You may also make use of two helper functions (defined in switchyard.lib.packet, which is already imported in the template file). create_ip_arp_reply(senderhwaddr, targethwaddr, senderprotoaddr, targetprotoaddr) create_ip_arp_request(senderhwaddr, senderprotoaddr, targetprotoaddr) Note that these two functions above return a full Packet object including Ethernet and Arp headers, all filled in. ✅ Show how you implement the logic of responding to the ARP request. Testing For initial testing and debugging of your code, you can run the Switchyard test scenario (routertests1.srpy). Run it like this: $ swyard -t lab_3/routertests1.srpy myrouter.py Read each individual test case output carefully (yes, it can be a lot to read!) since each test case has an explanation for what your code should be doing. Note that the test scenario file is not included in this repository, but is available on the NJU Box. ✅ In the report, show the test result of your router.(Optional) If you have written the test files yourself, show how you test your ARP responding logic. Deploying Once the Switchyard tests pass, you should test your router in Mininet. There is a start_mininet.py script available for building the following network topology: [!NOTE] Note that the above topology may not be the same as the one implied by the Switchyard tests. To test your router in Mininet, you can do the following: Open up a terminal on the virtual machine, and cd (if necessary) to the folder where your project files are located (or transfer them into the virtual machine). Then type the following to get Mininet started: $ sudo python lab_3/start_mininet.py Open up an xterm on the client node: mininet> xterm client Start up Wireshark on the client. From the xterm running on the client, type: client# wireshark -k & [!NOTE] You'll get some warnings from Wireshark about running as root, which you can safely ignore. Open an xterm on the router node: mininet> xterm router Start your router in the Python virtual environment: (syenv) router# swyard lab_3/myrouter.py Now, in the xterm running on the client, try to send an ICMP echo request to the IP address at the \"other end\" of the link between the client and the router. client# ping -c3 10.1.1.2 The router should initially receive an ARP request for its own IP address (which your router will need to correctly respond to!), then it should receive an ICMP echo request. Since your router isn't yet programmed to respond to ping requests, nothing else should happen (i.e., you'll get ping requests, but they won't be responded to). In Wireshark, you should see something similar to the following details when you click on the ARP request packet the first line in the capture window. Notice that the \"target MAC address\" is currently all zeroes, since this is the address being requested: Also in Wireshark, you should see the following details when you click on the ARP response packet (second line in the capture window). Notice that all the addresses in the ARP header are now filled in (and that source and destination addresses are effectively swapped): So here is our example. Your task is: ping the router from another host (server1 or server2). Using Wireshark to prove that you have handled ARP requests well. ✅ Write the procedure and analysis in your report with screenshots. "},"content/ch03/subch01/arp-table.html":{"url":"content/ch03/subch01/arp-table.html","title":"Task 3: Cached ARP Table","keywords":"","body":"Task 3: Cached ARP Table Construct cached ARP Table You'll eventually need to store a mapping in the Router between destination IP addresses and Ethernet MAC addresses (you can assume there is a one-to-one mapping). The reason is simple: when you send an IP packet to another host, you'll also need the Ethernet address associated with the destination IP address. If you \"remember\" any source IP/Ethernet MAC pairs from ARP requests that are received at the router, it may help you to avoid having to construct and send an ARP request to obtain the same information. This capability will likely be helpful to have in place for future stages of building the router. The cache table is similar to the table used in Ethernet learning switch. For each entry there are two or more fields in which IP and MAC Address is required. The cached ARP table may look like: IP MAC Address 10.1.2.3 01:02:03:04:05:06 ... ... When the router receives a packet with ARP header, add or update an entry of the cached ARP table. For example, if there is an ARP request with the Ethernet source address 01:02:03:04:05:06 and the IP source address 10.1.2.3, the router will update the entry whose key is 10.1.2.3 with the value 01:02:03:04:05:06. You can also see here that the IP address is unique in the table. Generally, the ARP table has a timeout mechanism. It indicates the time for which the MAC address in the ARP cache can reside. In this task, implementing this mechanism is optional. Coding Modify lab_3/myrouter.py and add the cache table. It is more convenient if you are familiar with Object-Oriented Programming (OOP). You can construct a class to maintain the ARP cache table. A brief tutorial of OOP in Python is here. Though OOP is no need in our lab assignments. Another useful data structure in Python is dict. The data structure dict is a table. Each entry of the table contains one unique key and one value. The introduction of dict is here. ✅ In your report, show how you construct the ARP table. Testing There are no test cases that can check the output of your router. So we decide you to print the cached ARP table when you update the table. You can log into the terminal or file. ✅ In your report, show the cached ARP table with screenshots. Explain how entries have changed. "},"content/ch03/subch02/lab-4.html":{"url":"content/ch03/subch02/lab-4.html","title":"Lab 4: Forwarding Packets","keywords":"","body":"Lab 4: Forwarding Packets Overview This is the second in a set of exercises that have the ultimate goal of creating the \"brains\" for an IPv4 router. The basic functions of an Internet router are to: Respond to ARP (address resolution protocol) requests for addresses that are assigned to interfaces on the router. (Remember that the purpose of ARP is to obtain the Ethernet MAC address associated with an IP address so that an Ethernet frame can be sent to another host over the link layer.) Receive and forward packets that arrive on links and are destined to other hosts. Part of the forwarding process is to perform address lookups (\"longest prefix match\" lookups) in the forwarding table. We will just use \"static\" routing in our router rather than implement a dynamic routing protocol like RIP or OSPF. Make ARP requests for IP addresses that have no known Ethernet MAC address. A router will often have to send packets to other hosts, and needs Ethernet MAC addresses to do so. Respond to ICMP messages like echo requests (\"pings\"). Generate ICMP error messages when necessary, such as when an IP packet's TTL (time to live) value has been decremented to zero. The goal of this stage is accomplish items 2 and 3 above. Your Tasks After Lab 3, you have implemented the response to ARP on the starter template: myrouter.py. Now, on the basis of Lab 3, we continue to improve the router to implement the function of packets forwarding. The main task for this exercise is to modify the Router class to do the following: [!NOTE] The sentences marked with ✅ are related to the content of your report. Please pay attention. Task 1: Preparation Initiate your project with our template. Start the task here Task 2: IP Forwarding Table Lookup Build a forwarding table and match the destination addresses. Start the task here Task 3: Forwarding the Packet and ARP Send an ARP query to create a new Ethernet header and forward the packet. Start the task here Handing it in Report We will provide a template of your lab assignment report here. You need to submit the report in your repository named _lab_4. The format of your report can be Microsoft Doc or PDF. An example is 123456789拾佰仟_lab_4.pdf. Submit to NJU GitLab To submit your work, you need to do the following things. Modify your code and complete your report. When you have done your work, put your report and code in the folder lab_4 then commit them. Tag the commit named which you want to submit. An example is 123456789/lab_4. Finally your project will look like switchyard ├─docs/ ├─.../ + ├─lab_4/ + │ ├─123456789拾佰仟_lab_4.pdf + │ ├─myrouter.py + │ ├─forwarding_table.txt │ ├─... + │ └─start_mininet.py ├─.gitignore └─... [!WARNING] The file names in your submission have to exactly match the file names above. Otherwise, you will lose points! Submit your work by pushing your local repository to your remote repository with your tags by running the command git push origin --tags. [!WARNING] Only commit your source code to your local repository. If there are some generated files that are not source code, ignore them by adding them in the file .gitignore. "},"content/ch03/subch02/preparation.html":{"url":"content/ch03/subch02/preparation.html","title":"Task 1: Preparation","keywords":"","body":"Preparation You have implemented a part of router in lab_3/myrouter.py. We will start with it. Create a directory named lab_4 in switchyard. Copy lab_3/start_mininet.py to lab_4/start_mininet.py. Copy lab_3/myrouter.py to lab_4/myrouter.py. Copy examples/exercises/router/forwarding_table.txt to lab_4/forwarding_table.txt. Though we will provide the test files, they are incomprehensible. So you should still write test scenarios that test all aspects of your code. You can find our test files below. Download it and you will use it to test your router later. You can unzip the test files we provide into the folder lab_4. Download compiled test cases here. Finally, your project will look like switchyard ├─docs/ ├─.../ + ├─lab_4/ + │ ├─myrouter.py + │ ├─forwarding_table.txt │ ├─... + │ └─start_mininet.py ├─.gitignore └─... [!WARNING] All of your modifications should be done on the files under your directory lab_4. We will check and compare the git commits to judge the originality of your work. So remember to commit every time you complete one small task. "},"content/ch03/subch02/forwarding-table-lookup.html":{"url":"content/ch03/subch02/forwarding-table-lookup.html","title":"Task 2: IP Forwarding Table Lookup","keywords":"","body":"Task 2: IP Forwarding Table Lookup IP Forwarding Table Build and Lookup One of the key tasks to accomplish for this project is to perform the fundamental thing that routers do: receive packets, match their destination addresses against a forwarding table, and forward them out the correct interface. Build Forwarding Table You will need to implement some kind of forwarding table, with each entry containing the following: A network prefix (e.g., 149.43.0.0), A network \"mask\" (e.g., 255.255.0.0), The \"next hop\" IP address, if the destination network prefix is not for a directly attached network, and, The network interface name through which packets destined to the given network should be forwarded. You will need to build the forwarding table from two sources: the list of router interfaces you get through a call to the net.interfaces() (or net.ports()) method and by reading in the contents of a file named forwarding_table.txt. An example forwarding table file is found in the project directory, and is also recreated each time you either run the test scripts or run your router in Mininet. Your code can simply assume that a file named forwarding_table.txt exists in the current working directory. [!NOTE] Your forwarding table may be different for the test scenario and for Mininet to help ensure that your router behaves in a general way and isn't written just to handle a specific set of forwarding table entries Note that for each interface object in the list obtained from net.interfaces() (or, equivalently, net.ports()), the IP address assigned to the interface and the network mask are available (see the Switchyard documentation on getting information about interfaces/ports). The file forwarding_table.txt can be assumed to exist in the same directory where your router is starting up (again, this file is produced by the Switchyard test scenario or by the Mininet startup script), and is structured such that each line contains 4 space-separated items: the network address, the subnet mask, the next hop address, and the interface through which packets should be forwarded. Here are some example lines: 172.16.0.0 255.255.255.0 192.168.1.2 router-eth0 192.168.200.0 255.255.255.0 192.168.200.1 router-eth1 In the first line, the network address is 172.16.0.0 and the subnet mask is 255.255.0.0. The next hop IP address is 192.168.1.2, and the interface through which to forward packets is named router-eth0. Match Destination IP Addresses against Forwarding Table After you build the forwarding table (which should be done once, upon startup), destination addresses in IP packets received by the router should be matched against the forwarding table. Remember that in case of two items in the table matching, the longest prefix match should be used. Two special cases to consider: If there is no match in the table, just drop the packet. (We'll handle this better in a later stage of creating the router.) If packet is for the router itself (i.e., destination address is an address of one of the router's interfaces), also drop/ignore the packet. (We'll also handle this better at a later stage.) Coding Your task is to implement the logic described above. The start file is named lab_4/myrouter.py. There are a couple functions and methods in the Python 3's ipaddress library (also available through Switchyard's IP address library) that are helpful for building forwarding table entries and/or for matching destination IP addresses against forwarding table entries: To find out the length of a subnet prefix, you can use the following code pattern: from switchyard.lib.address import * netaddr = IPv4Network('172.16.0.0/255.255.255.0') netaddr.prefixlen # -> 24 Note in the code above that you simply need to concatenate an IP address with '/' and the netmask when constructing a IPv4Network object. The resulting object can tell you the length of the prefix in bits, which will be quite helpful. The IPv4Address class can be converted to an integer using the standard int() type conversion function. This function will return the 32-bit unsigned integer representation of an IP address. Remember that you can use bit-wise operations on Python integers (& is bitwise AND, | is bitwise OR, ~ is bitwise NOT, ^ is bitwise XOR). For example, if we wanted to check whether a given address matches a prefix, we might do something like this: prefix = IPv4Address('172.16.0.0') destaddr = IPv4Address('172.16.23.55') matches = (int(prefix) & int(destaddr)) == int(prefix) # matches -> True You can also use capabilities in the IPv4Network class to do the same thing: prefixnet = IPv4Network('172.16.0.0/16') # same as IPv4Network('172.16.0.0/255.255.0.0') matches = destaddr in prefixnet # matches -> True ✅ In the report, show how you implement the logic of building IP forwarding table and matching the destination IP addresses. Testing As the function has not been fully implemented, there is no test cases can check the output of your router. "},"content/ch03/subch02/make-arp-request.html":{"url":"content/ch03/subch02/make-arp-request.html","title":"Task 3: Forwarding the Packet and ARP","keywords":"","body":"Task 3: Forwarding the Packet and ARP Send ARP Request and Forward Packet Once you do the forwarding table lookup for an IP destination address, the next steps are to: Decrement the TTL field in the IP header by 1 (you could do this prior to forwarding table lookup, too). You can assume for this project that the TTL value is greater than 0 after decrementing. We'll handle \"expired\" TTLs in the next project. Create a new Ethernet header for the IP packet to be forwarded. To construct the Ethernet header, you need to know the destination Ethernet MAC address corresponding to the host to which the packet should be forwarded. The next hop host is either: the destination host, if the destination address is directly reachable through one of the router interfaces (i.e., the subnet that the destination address belongs to is directly connected to a router interface), or it is an IP address on a router through which the destination is reachable. In either case, you will need to send an ARP query in order to obtain the Ethernet address corresponding to the next hop IP address. For handling ARP queries you should do the following: Send an ARP request for the IP address needing to be \"resolved\" (i.e., the IP address for which you need the corresponding Ethernet address). The Switchyard reference documentation for the ARP header has an example of constructing an ARP request packet. When an ARP reply is received, complete the Ethernet header for the IP packet to be forwarded, and send it along. You should also create a cache of IP addresses and the Ethernet MAC addresses that they correspond to (you have done in Lab 3 Task 3). When you receive a response to an ARP query, add the IP address → Ethernet address mapping to the cache so that you can avoid doing an identical ARP query. If no ARP reply is received within 1 second in response to an ARP request, send another ARP request. Send up to (exactly) 5 ARP requests for a given IP address. If no ARP reply is received after 5 requests, give up and drop the packet (and do nothing else). Lastly, refer to the Switchyard documentation details and examples for parsing and constructing packets containing Ethernet, ARP, and IP packet headers. Packet parsing/construction introduction Packet parsing/construction reference Ethernet header reference ARP header reference IPv4 header reference Coding Your task is to implement the logic described above. The start file is named lab_4/myrouter.py. You will need to carefully structure your code to be able to receive and process incoming packets while you are waiting for replies to ARP requests. A suggested method is to create a queue that contains information about IP packets awaiting ARP resolution. Each time through the main while loop in your code, you can process the items in the queue to see whether an ARP request retransmission needs to be sent. If you receive an ARP reply packet, you could remove an item from the queue, update the ARP table, construct the Ethernet header, and send the packet. You might create a separate class to represent packets in the queue waiting for ARP responses, with the class containing variables to hold the most recent time an ARP request was sent, and the number of retries, among other things. [!NOTE] You can create a separate Python thread to handle ARP requests. Switchyard is thread-safe and this is an acceptable pattern. You may find it easier, however, to simply handle everything in the main thread of the router. For keeping track of how long it has been since an ARP request has been sent, you can use the built-in time module. It has a time function that returns the current time in seconds (as a floating point value) (e.g., time.time() # → current time in seconds as a float). ✅ In the report, show how you implement the logic of forwarding the packet and ARP. Testing To test your router, you can use the same formula you've used in the past: $ swyard -t routertests2.srpy myrouter.py This project includes quite a bit of complexity, so inspecting variables and stepping through your program in the debugger can be extremely helpful! If you need to step through code to see what's going on, you can add calls to debugger() at any point in your code. When execution reaches that line, you'll get a Python debugger (pdb) command line at which you can inspect variables, call methods, etc., in order to understand what's happening. This kind of debugging will, in general, be much more effective than \"printf\" debugging. Another way is using VS Code to debug, which is more convenient than using pdb. But you need to be familiar with debugging in VS Code. An example we show is in Lab 1 Task 2. Note that the test scenario file is not included in this repository, but is available on the NJU Box. ✅ In the report, show the test result of your router.(Optional) If you have written the test files yourself, show how you test the forwarding packets. Deploying Once the Switchyard tests pass, you should test your router in Mininet. There is a start_mininet.py available for building the following network topology: [!NOTE] The above topology is not the same as the one implied by the Switchyard tests. To test your router in Mininet, open up a terminal on the virtual machine, and cd (if necessary) to the folder where your project files are located (or transfer them into the virtual machine). Then type: $ sudo python start_mininet.py Once Mininet starts up, you should open an xterm on the router node (xterm router), and type the command below to start your router. router# swyard myrouter.py [!NOTE] Again, you may need to activate your Python virtual environment in order for the above command to work correctly. [!TIP] When you run your router in Mininet, you'll almost certainly receive packets that you didn't ask for! In particular, you'll likely receive non-IPv4 and non-ARP packets (you'll likely receive some IPv6 packets and some other fun stuff). You should just ignore these non-IPv4 and non-ARP packets (and your router should not crash when it receives them!) At this point, you should be able to open another xterm on any one of the other nodes and send a ping (ICMP echo request) to any of the IP addresses configured on any node in the network. For example, if you open an xterm on client, you should be able to send a ping to 192.168.200.1 (on server2) and 192.168.100.1 (on server1). You should also be able to send a ping to any address in the subnets 192.168.100.0/24 and 192.168.200.0/24 from the client node, and the router should successfully forward them to either server1 or server2. (But note that you will only get ping responses from 192.168.100.1 and 192.168.200.1 --- pings to any other IP address will not get a response.) To test whether the router is correctly forwarding the packets, you can run Wireshark on any of the nodes in the network. Below is an example of starting Wireshark on the router using interface router-eth2, then running ping on the client to send 2 ICMP echo requests to 192.168.100.1: On the router run router# wireshark -i router-eth2 On the client run client# ping -c2 192.168.100.1 You will see the Wireshark on the router-eth2 capture these packets. Testing your router in the \"live\" network (i.e., in Mininet) is a major step: if it passes all the tests then works in Mininet when trying various examples of pinging hosts, you might have done things correctly! Your task is: ping another host (client or server2) from server1. Using Wireshark to prove that your router is correctly forwarding the packets. ✅ Write the procedure and analysis in your report with screenshots. "},"content/ch03/subch02/faq.html":{"url":"content/ch03/subch02/faq.html","title":"FAQ","keywords":"","body":"FAQ Q: What should the router do in the following scenario: say a packet for a certain IP address arrives at the router and it sends an ARP request to obtain the corresponding MAC address. Before receiving the ARP reply, the router receives another packet (non-ARP) for the same IP address, should it send an ARP request again? A: No, in this case you should not retransmit the ARP request for the second packet. More generally, your router might receive many packets for a certain IP address while there is an outstanding ARP request for that IP address. In this case, your router should not send out any new ARP requests or update the timestamp of the initial ARP request. However, your router should buffer the new data packets so that it can transmit them to the destination host once it receives the ARP reply. IMPORTANT: If your router buffers multiple packets for a destination host that has an outstanding ARP request, upon receiving the corresponding ARP reply these packets has to be forwarded to the destination host in the order they arrived to the router! Q: When an ARP request arrives at the router for a destination IP address that is not assigned to one of the router's interfaces, does the router need to flood the ARP request, or should it just drop the request? A: Your router should drop the packet in this case. Q: When the router needs to make an ARP request for the next hop IP address (which is obtained after the longest prefix match lookup), should it flood the request on all ports? A: The router does not flood the ARP request on all ports. The ARP query is merely sent to the broadcast Ethernet address on the port obtained from doing a longest prefix match lookup. The response ARP query should come back on the same port but it doesn't actually need to (and it doesn't matter for the purposes of forwarding the packet or sending out the ARP request). "},"content/ch03/subch03/lab-5.html":{"url":"content/ch03/subch03/lab-5.html","title":"Lab 5: Respond to ICMP","keywords":"","body":"Lab 5: Respond to ICMP Overview This is the third stage in a series of exercises that have the ultimate goal of creating an IPv4 router. The basic functions of an Internet router are to: Respond to ARP (address resolution protocol) requests for addresses that are assigned to interfaces on the router. (Remember that the purpose of ARP is to obtain the Ethernet MAC address associated with an IP address so that an Ethernet frame can be sent to another host over the link layer.) Receive and forward packets that arrive on links and are destined to other hosts. Part of the forwarding process is to perform address lookups (\"longest prefix match\" lookups) in the forwarding table. We will just use \"static\" routing in our router rather than implement a dynamic routing protocol like RIP or OSPF. Make ARP requests for IP addresses that have no known Ethernet MAC address. A router will often have to send packets to other hosts, and needs Ethernet MAC addresses to do so. Respond to ICMP messages like echo requests (\"pings\"). Generate ICMP error messages when necessary, such as when an IP packet's TTL (time to live) value has been decremented to zero. The goal of this stage of the project is to accomplish items 4 and 5 above. When you're done with this project, you will have a fully functioning Internet router. Your Tasks After the efforts of Lab 3 and Lab 4, you have implemented part of the functions of the router, including the response to ARP and the forwarding of packets. Next, you need to continue to improve your router in the myrouter.py so that it can respond to ICMP messages. The main task for this exercise is to modify the Router class to do the following: [!NOTE] The sentences marked with ✅ are related to the content of your report. Please pay attention. Task 1: Preparation Initiate your project with our template. Start the task here Task 2: Responding to ICMP echo requests Respond to ICMP messages like echo requests (\"pings\"). Start the task here Task 3: Generating ICMP error messages Generate ICMP error messages when necessary. Start the task here Handing it in Report We will provide a template of your lab assignment report here. You need to submit the report in your repository named _lab_5. The format of your report can be Microsoft Doc or PDF. An example is 123456789拾佰仟_lab_5.pdf. Submit to NJU GitLab To submit your work, you need to do the following things. Modify your code and complete your report. When you have done your work, put your report and code in the folder lab_5 then commit them. Tag the commit named which you want to submit. An example is 123456789/lab_5. Finally your project will look like switchyard ├─docs/ ├─.../ + ├─lab_5/ + │ ├─123456789拾佰仟_lab_5.pdf + │ ├─myrouter.py + │ ├─forwarding_table.txt │ ├─... + │ └─start_mininet.py ├─.gitignore └─... [!WARNING] The file names in your submission have to exactly match the file names above. Otherwise, you will lose points! Submit your work by pushing your local repository to your remote repository with your tags by running the command git push origin --tags. [!WARNING] Only commit your source code to your local repository. If there are some generated files that are not source code, ignore them by adding them in the file .gitignore. "},"content/ch03/subch03/preparation.html":{"url":"content/ch03/subch03/preparation.html","title":"Task 1: Preparation","keywords":"","body":"Preparation You can start with copying the content of lab_4/myrouter.py to lab_5/myrouter.py. Create a directory named lab_5 in switchyard. Copy lab_4/start_mininet.py to lab_5/start_mininet.py. Copy lab_4/myrouter.py to lab_5/myrouter.py. Copy lab_4/forwarding_table.txt to lab_5/forwarding_table.txt. Though we will provide the test files, they are incomprehensible. So you should still write test scenarios that test all aspects of your code. You can find our test files below. Download it and you will use it to test your switch later. You can unzip the test files we provide into the folder lab_5. Download compiled test cases here. Finally, your project will look like switchyard ├─docs/ ├─.../ + ├─lab_5/ + │ ├─myrouter.py + │ ├─forwarding_table.txt │ ├─... + │ └─start_mininet.py ├─.gitignore └─... [!WARNING] All of your modifications should be done on the files under your directory lab_5. We will check and compare the git commits to judge the originality of your work. So remember to commit every time you complete one small task. "},"content/ch03/subch03/respond-ICMP.html":{"url":"content/ch03/subch03/respond-ICMP.html","title":"Task 2: Responding to ICMP echo requests","keywords":"","body":"Task 2: Responding to ICMP echo requests Procedure The first key task for this is for the router to respond to ICMP echo request (\"pings\") sent to an address assigned to one of its interfaces. Prior to making a forwarding decision for an incoming IP packet (i.e., a forwarding table lookup), you should first check whether the IP destination address is the same as one of the addresses assigned to one of the router's interfaces. If the packet is also an ICMP echo request, then you should construct an ICMP echo reply and send it back to the original host that sent the ping. To do that, you should: Construct an ICMP header + echo reply, correctly populating the fields in the header. See the Switchyard documentation for details on ICMP packet headers. When creating the EchoReply, do the following: Copy the EchoRequest sequence number into the EchoReply you make, and also copy the identifier in the EchoRequest into the EchoReply, and set the data field in the EchoReply to be the same as the data in the EchoRequest. Construct an IP header, which should have the destination IP address set as the source address of the incoming ICMP echo request, and the IP source address set as the router's interface address. The next header in the packet should be the ICMP header that you created. Send (forward) the packet you constructed. You should already have code from the previous stage of the router to do forwarding table lookups and ARP requests to handle this part. If you've designed this part of your router reasonably well, this should just be a method/function call for forwarding the echo response. Coding Your task is to implement the logic described above. The start file is named lab_5/myrouter.py. ✅ In the report, show how you implement the logic of responding to ICMP echo requests. Testing Wait until Task 3 is completed before testing. "},"content/ch03/subch03/generate-error-messages.html":{"url":"content/ch03/subch03/generate-error-messages.html","title":"Task 3: Generating ICMP error messages","keywords":"","body":"Task 3: Generating ICMP error messages ICMP error cases There are 4 situations in which you'll need to generate ICMP error messages. To this point, we have either explicitly ignored these error cases, or simply haven't considered them. The following describes the specific cases, and the ICMP error message you'll need to generate in response to them: When attempting to match the destination address of an IP packet with entries in the forwarding table, no matching entries are found (i.e., the router doesn't know where to forward the packet). In this case, an ICMP destination network unreachable error should be sent back to the host referred to by the source address in the IP packet. Note: the ICMP type should be destination unreachable, and the ICMP code should be network unreachable. After decrementing an IP packet's TTL value as part of the forwarding process, the TTL becomes zero. In this case, an ICMP time exceeded error message should be sent back to the host referred to by the source address in the IP packet. Note: the ICMP code should be TTL expired. ARP Failure. During the forwarding process, the router often has to make ARP requests to obtain the Ethernet address of the next hop or the destination host. If there is no host that \"owns\" a particular IP address, the router will never receive an ARP reply. If after 5 retransmission of an ARP request the router does not receive an ARP reply, the router should send an ICMP destination host unreachable back to the host referred to by the source address in the IP packet. Note: the ICMP type should be destination unreachable, and the ICMP code should be host unreachable. An incoming packet is destined to an IP addresses assigned to one of the router's interfaces, but the packet is not an ICMP echo request The only packets destined for the router itself that it knows how to handle are ICMP echo requests. Any other packets should cause the router to send an ICMP destination port unreachable error message back to the source address in the IP packet. Note: the ICMP type should be destination unreachable, and the ICMP code should be port unreachable. Again, refer to the Switchyard documentation on ICMP headers. Coding Your task is to implement the logic described above. The start file is named lab_5/myrouter.py. For creating any ICMP error packet (i.e., any of the packets in the table above), you must include as the \"data\" payload of the ICMP header up to the first 28 bytes of the original packet, starting with the IPv4 header. (That is, your ICMP message will include part of the packet that caused the problem.) The switchyard documentation has an example of doing this, and an example is also given below. Also, be careful to make sure that the newly constructed IP packet you send has a non-zero TTL --- by default, when you create a new IPv4 header, the TTL value is zero (0). A code formula for including the \"dead\" packet in the ICMP payload is shown below: >>> origpkt = Ethernet() + IPv4() + ICMP() # assume this is the packet that caused the error >>> i = origpkt.get_header_index(Ethernet) >>> del origpkt[i] # remove Ethernet header --- the errored packet contents sent with >>> # the ICMP error message should not have an Ethernet header >>> icmp = ICMP() >>> icmp.icmptype = ICMPType.TimeExceeded >>> icmp.icmpdata.data = origpkt.to_bytes()[:28] >>> str(icmp) \"ICMP TimeExceeded:TTLExpired 28 bytes of raw payload (b'E\\\\x00\\\\x00\\\\x1c\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x01') OrigDgramLen: 0\" >>> ip = IPv4() >>> ip.protocol = IPProtocol.ICMP # protocol defaults to ICMP; >>> # setting it explicitly here anyway >>> # would also need to set ip.src, ip.dst, and ip.ttl to something non-zero >>> pkt = ip + icmp >>> print(pkt) IPv4 0.0.0.0->0.0.0.0 ICMP | ICMP TimeExceeded:TTLExpired 28 bytes of raw payload (b'E\\x00\\x00\\x1c\\x00\\x00\\x00\\x00\\x00\\x01') OrigDgramLen: 28 ✅ In the report, show how you implement the logic of generating ICMP error messages. Testing To test your router, you can use the same formula you've used in the past: $ swyard -t routertests3.srpy myrouter.py Note that the test scenario file is not included in this repository, but is available on the NJU Box. ✅ In the report, show the test result of your router.(Optional) If you have written the test files yourself, show how you test the forwarding packets. Deploying Once the Switchyard tests pass, you should test your router in Mininet. There is a start_mininet.py script available for building the following network topology: (Note that the above topology is not the same as the one implied by the Switchyard tests.) To test each of the new router functionalities in Mininet, you can open up a terminal on the virtual machine, and cd (if necessary) to the folder where your project files are located (or transfer them into the virtual machine). Then type the following to get Mininet started: $ sudo python start_mininet.py Once Mininet is running, open a terminal on the router node (xterm router) and get the router running (swyard myrouter.py). Again, be aware that you may need to activate a Python virtual environment in order for this command to succeed. Next, open a terminal on the client node (xterm client). Now, you should be able to: Use the ping tool to send an ICMP echo request to an IP address configured on one of the router's interfaces. Ping should successfully report that it is receiving replies to the echo requests. You can also use the ping tool and specifically set the initial TTL in the ICMP packets to be 1, so that when your router receives them, it will decrement the TTL to zero and generate an ICMP time exceeded error. The -t flag to ping allows you to explicitly set the TTL. For example: client# ping -c 1 -t 1 192.168.200.1 You can send a ping from the client to an address that doesn't have a match in the router's forwarding table. There is a route set up on the client to forward traffic destined to 172.16.0.0/16 to the router, but the router doesn't have any forwarding table entry for this subnet. So the following ping should result in an ICMP destination net unreachable message sent back to the client: client# ping -c 1 172.16.1.1 Probably the most complicated test you can run is to do a \"traceroute\" across the toy network in Mininet. From the client, type: client# traceroute -N 1 -n 192.168.100.1 The output you see should be similar to the following: traceroute to 192.168.100.1 (192.168.100.1), 30 hops max, 60 byte packets 1 10.1.1.2 409.501 ms 201.130 ms 200.578 ms 2 192.168.100.1 607.775 ms 401.868 ms 401.920 ms If you can get this working, then you can have pretty high confidence that everything in your router works correctly. Congratulations! Your task is: test your router from another host (server1 or server2) as described above. Using Wireshark to prove that your router can correctly respond to ICMP messages and generate ICMP error messages when necessary. ✅ Write the procedure and analysis in your report with screenshots. "},"content/ch03/subch03/faq.html":{"url":"content/ch03/subch03/faq.html","title":"FAQ","keywords":"","body":"FAQ Q: When sending ICMP echo replies or error messages, does the router need to do a forwarding table lookup and send ARP requests if needed? Can't the router just send the ICMP messages back on the interface through which the IP packet was received? A: The router will still need to do an ARP query as it normally does for forwarding an IP packet. It doesn't matter that an echo request arrives on, say port eth0. The echo reply may end up going out on a different port depending on the forwarding table lookup. The entire lookup and ARP query process should be the same as forwarding an IP packet, and will always behave exactly this way. Q: How many error messages should be generated if a packet has TTL expired and network unreachable errors at the same time? A: Your router will only generate a network unreachable error in this case. Since the router decrements the TTL field after doing a lookup, if the lookup fails then your router will not reach at decrementing the TTL value. Q: If there are multiple packets buffered for the same destination host or next hop and the router doesn't receive an ARP reply after sending 5 retransmissions of ARP requests what should the router do? A: Your router should send an ICMP destination host unreachable message back to the host referred to by the source address in the IP packet. When there are multiple packets buffered for the same destination address, the router will send an ICMP error message to each source host of these packets (even if the same source host sent multiple packets). "},"content/ch03/faq.html":{"url":"content/ch03/faq.html","title":"FAQ","keywords":"","body":"FAQ Q: What should the router do in the following scenario? Packet for a certain IP address arrives at the router and it sends an ARP request to find the MAC address. Before receiving the ARP reply, the router receives another packet (non-ARP) for the same IP address, does it send an ARP request again? A: No, in this case you do not retransmit the ARP request for the second packet. More generally, your router might receive many packets for a certain IP address while there is an outstanding ARP request for that IP address. In this case, your router should not send out any new ARP requests or update the timestamp of the initial ARP request. However, your router should buffer the new data packets so that it can transmit them to the destination host once it receives the ARP reply. IMPORTANT: If your router buffers multiple packets for a destination host that has an outstanding ARP request, upon receiving the corresponding ARP reply these packets has to be forwarded to the destination host in the order they arrived to the router! Q: When an ARP request arrives at the router for a destination IP address that is not assigned to one of the router's interfaces, does the router need to flood the ARP request? Or just drop it? A: Your router should drop the packet in this case. Note: In stage 1, you should be checking to see if the destination IP address is an IP address assigned to one of the router's interfaces. However, for stage two and three, check to see if the destination IP address is an IP address in the ARP table Q: When the router needs to make an ARP request for the next hop IP address (which is obtained after the longest prefix match lookup), should it flood the request on all ports? A: The router does not flood the ARP request on all ports. The ARP query is merely broadcast on the port obtained from doing a longest prefix match lookup. The response ARP query should come back on the same port but it doesn't actually need to (and it doesn't matter for the purposes of forwarding the packet or sending out the ARP request). Q: When sending ICMP echo replies or error messages, does the router need to do table lookup & send ARP requests if needed? Can the router send the ICMP messages back on the interface through which the IP packet was received? A: The router will still need to do an ARP query as it normally does for forwarding an IP packet. It doesn't matter that an echo request arrives on, say port 0. The echo reply may end up going out on a different port depending on the forwarding table lookup. The entire lookup and ARP query process should be the same as forwarding an IP packet, and will always behave exactly this way. Q: How many error messages will be generated if a packet has TTL expired and network unreachable errors at the same time? A: Your router will only generate a network unreachable error in this case. Since the router decrements the TTL field after doing a lookup, if the lookup fails then your router will not reach at decrementing the TTL value. Q: Following up from Q1: if there are multiple packets buffered for the same destination host or next hop and the router doesn't receive an ARP reply after sending 5 retransmissions of ARP requests what should the router do? A: As it is explained in the part 3 of the project, your router will send an ICMP destination host unreachable message back to the host referred to by the source address in the IP packet. When there are multiple packets buffered for the same destination address, the router will send an ICMP error message to each source host of these packets (even if the same source host sent multiple packets). Q: Part of the instructions say if the packet is for us (i.e. it's destination ipaddr is in net.interfaces) then drop it. But later on, the instructions say that if the packet is meant for one of our directly connected neighbors then we forward it. How is net.interfaces() different than the directly connected networks. A: The net.interfaces() is the information for the interfaces on the router itself. For example, eth1 might have an ipaddr of 192.168.1.1. However, from these interfaces you can use the ipaddr and netmask to get the subnet that the interface is directly connected to. So if the netmask of 255.255.255.0 for the same eth1, then the subnet would be the mask applied to the ipaddr which is 192.168.1.0. So, if a packet came to the router destined for an ip address like 192.168.1.100, then you would find a match in the forwarding table and end up forwarding the packet out eth1. But if a packet came to the router destined for 192.168.1.1, then you would drop it, since that is the exact ip address of the interface. Q: In the instruction of our project, we are told that the echo reply may end up going out on a different port depending on the forwarding table lookup. What does this mean? A: The source ip address of the ICMP response does not necessarily need to be the ip address of the interface that you are sending the reply packet out of. The ICMP reply should have an ip.src and ip.dst that are the the ip.dst and ip.src of the ICMP request respectively (that is just switch them around). However, the destination address is looked up in the forwarding table to determine what port to send the reply out of. So the src ip address and the port of the ICMP reply may not match up to the same interface. "},"content/ch04/lab-6.html":{"url":"content/ch04/lab-6.html","title":"Lab 6: Reliable Communication","keywords":"","body":"Lab 6: Reliable Communication Overview In your final assignment you are going to build a reliable communication library in Switchyard that will consist of 3 agents. At a high level, a blaster will send data packets to a blastee through a middlebox. As you should all know by know, IP only offers a best-effort service of delivering packets between hosts. This means all sorts of bad things can happen to your packets once they are in the network: they can get lost, arbitrarily delayed or duplicated. Your communication library will provide additional delivery guarantees by implementing some basic mechanisms at the blaster and blastee. Let's move on to the details. Your Tasks In the source directory for this exercise, you can find the starter files: middlebox.py, blastee.py and blaster.py. Your reliable communication library will implement the following features to provide additional guarantees: ACK mechanism on blastee for each successfully received packet A fixed-size sliding window on blaster Coarse timeouts on blaster to resend non-ACK'd packets Further details will be discussed in each Task. [!NOTE] The sentences marked with ✅ are related to the content of your report. Please pay attention. Task 1: Preparation Initiate your project with our template. Start the task here Task 2: Middlebox Implement the features of middlebox. Start the task here Task 3: Blastee Implement the features of blastee. Start the task here Task 4: Blaster Implement the features of blaster. Start the task here Task 5: Running your code Make sure that your blaster, blastee and middlebox function correctly. Start the task here [!WARNING] Please carefully read the FAQ section, for more specific details regarding the implementations. Handing it in Report We will provide a template of your lab assignment report here. You need to submit the report in your repository named _lab_6. The format of your report can be Microsoft Doc or PDF. An example is 123456789拾佰仟_lab_6.pdf. Submit to NJU GitLab To submit your work, you need to do the following things. Modify your code and complete your report. When you have done your work, put your report and code in the folder lab_6 then commit them. Tag the commit named which you want to submit. An example is 123456789/lab_6. Finally your project will look like switchyard ├─docs/ ├─.../ + ├─lab_6/ + │ ├─123456789拾佰仟_lab_6.pdf + │ ├─middlebox.py + │ ├─middlebox_params.txt + │ ├─blastee.py + │ ├─blastee_params.txt + │ ├─blaster.py + │ ├─blaster_params.txt │ ├─... + │ └─start_mininet.py ├─.gitignore └─... [!WARNING] The file names in your submission have to exactly match the file names above. Otherwise, you will lose points! Submit your work by pushing your local repository to your remote repository with your tags by running the command git push origin --tags. [!WARNING] Only commit your source code to your local repository. If there are some generated files that are not source code, ignore them by adding them in the file .gitignore. "},"content/ch04/preparation.html":{"url":"content/ch04/preparation.html","title":"Task 1: Preparation","keywords":"","body":"Task 1: Preparation You can find the starter files in the directory: switchyard/examples/exercises/applayer. Let's start with it. Create a directory named lab_6 in switchyard. Copy examples/exercises/applayer/start_mininet.py to lab_6/start_mininet.py. Copy examples/exercises/applayer/middlebox.py to lab_6/middlebox.py. Copy examples/exercises/applayer/blastee.py to lab_6/blastee.py. Copy examples/exercises/applayer/blaster.py to lab_6/blaster.py. The example parameter files are available to make sure that we are on the same page on their format. Finally, your project will look like switchyard ├─docs/ ├─.../ + ├─lab_6/ + │ ├─123456789拾佰仟_lab_6.pdf + │ ├─middlebox.py + │ ├─middlebox_params.txt + │ ├─blastee.py + │ ├─blastee_params.txt + │ ├─blaster.py + │ ├─blaster_params.txt │ ├─... + │ └─start_mininet.py ├─.gitignore └─... [!WARNING] All of your modifications should be done on the files under your directory lab_6. We will check and compare the git commits to judge the originality of your work. So remember to commit every time you complete one small task. "},"content/ch04/middlebox.html":{"url":"content/ch04/middlebox.html","title":"Task 2: Middlebox","keywords":"","body":"Task 2: Middlebox Details Even though it's called a middlebox, in practice this will be a very basic version of the router you implemented in Lab 3-5. Your middlebox will have two ports each with a single connection: one to the blaster and one for the blastee. You will do the same packet header modifications(i.e layer 2) as in Lab 3-5. However instead of making ARP requests you will hard code the IP-MAC mappings into the middlebox code. This means, if the middlebox receives a packet from its eth0 interface(= from blaster), it will forward it out from eth1(= to blastee) and vice versa. This basic assumption also obviates the need to do forwarding table lookups. Regardless of the source IP address, just forward the packet from the other interface. So far so good. Now comes the fun part of the middlebox! Besides a very dumb forwarding mechanism, your middlebox will also be in charge of probabilistically dropping packets to simulate all the evil things that can happen in a real network. Packet drops will only happen in one direction, from blaster to blastee (i.e do not drop ACKs). Parameters The middlebox should read a text file to get parameters. Parse this file to setup your device. middlebox_params.txt will contain the following line: -d drop_rate: Percentage of packets (non-ACK) that your middlebox is going to drop, 0 ≤ drop_rate ≤ 1 Coding Your task is to implement the logic described above. The start file is named lab_6/middlebox.py. ✅ In the report, show how you implement the features of middlebox. "},"content/ch04/blastee.html":{"url":"content/ch04/blastee.html","title":"Task 3: Blastee","keywords":"","body":"Task 3: Blastee Details Blastee will receive data packets from the blaster and immediately ACK them. Blastee will extract the sequence number information from the received data packet and create an ACK packet with the same sequence number. Unlike TCP where sequence numbers work on bytes, your implementation will use sequence numbers at packet granularity. Parameters The blastee should read a text file to get parameters. Parse this file to setup your device. blastee_params.txt will contain the following line: -b -n blaster_IP: IP address of the blaster. This value has to match the IP address value in the start_mininet.py file num: Number of packets to be sent by the blaster Packet format The packets will have 3 headers: Ethernet, IPv4, UDP. It's obvious why you will have the first 2 headers. UDP header will serve as a placeholder to prevent Switchyard from complaining. You can read about the parameters of UDP header here. You can assign arbitrary values for the port values as you won't be using them. You will append your packet to this sequence of packets. I suggest you use the RawPacketContents header in Switchyard. It is just a packet header class that wraps a set of raw bytes. You can find some information about it on the same web site. You can also take a look at the source code to understand how it works. (You can find its source code at the bottom of this page.) Or better, you can just test it on your own! Here is how your ACK packet will look like: ------------------------------------------------------------------------------------------------------------- | ETH Hdr | IP Hdr | UDP Hdr | Sequence number(32 bits) | Payload (8 bytes) | ------------------------------------------------------------------------------------------------------------- Notice that the ACK packet will have a fixed size payload (8 bytes). You will populate these bytes from the first 8 bytes of the variable length payload of the blaster's packet that you received at the blastee. If the blaster's packet has a payload with less than 8 bytes, just pad the payload in ACK as you need. You will need to encode the sequence number in to your packets, which will be in raw byte format. Encoding should use big-endian format! Python has built-in library calls to achieve this with minimum pain. Coding Your task is to implement the logic described above. The start file is named lab_6/blastee.py. ✅ In the report, show how you implement the features of blastee. "},"content/ch04/blaster.html":{"url":"content/ch04/blaster.html","title":"Task 4: Blaster","keywords":"","body":"Task 4: Blaster Details Blaster will send/receive variable size IP packets/ACKs to/from the blastee. As mentioned above, it will implement a fixed-size sender window (SW) at packet granularity and coarse timeouts. In order to clarify how SW will work, let's define two variables LHS and RHS(both always >= 1), where LHS and RHS (correspond to sequence numbers of 2 sent packets that have not been necessarily ACKd yet) indicate the current borders of the SW such that it always satisfies the following: C1: RHS - LHS + 1 ≤ SW SW effectively puts a limit on the maximum number of unACKd packets that can be in-flight between the blaster and blastee. Logic of changing the RHS is simple, as the blaster sends packets it will increment the RHS value without violating the previous condition. However, changing the LHS value is more tricky. LHS tells us the packet with the lowest sequence number Si such that: C2: Every packet with sequence number Sj i has been successfully ACKd. Let's look at the following example to better understand this. Numbers in the boxes indicate the sequence number associated with each packet: Suppose SW=5. Initially LHS=1 and RHS=1 --------------------- | 1 | 2 | 3 | 4 | 5 | --------------------- ^ | LHS RHS Based on the explanations above, blaster will start sending packets and it will keep incrementing the RHS value. After sending the first 5 packets and not receiving any ACKs, the SW will look like this: --------------------- | 1 | 2 | 3 | 4 | 5 | --------------------- ^ ^ | | LHS RHS Note that we can't move the RHS any further otherwise we will violate C1. This also means that blaster can't send any new packet to the blastee until it starts receiving ACKs. Let's assume that ACKs for packets #1 and #2 arrive at the blaster. In this case LHS will point at #3 and therefore we can move the RHS to 7. --------------------- | 3 | 4 | 5 | 6 | 7 | --------------------- ^ ^ | | LHS RHS Now let's assume that the middlebox dropped packets #3 and #4, which means the blastee won't be able to ACK them. After a while, ACKs for #5 and #6 arrive at the blaster. ----------------------------------- | 3 | 4 | 5(ack'd) | 6(ack'd) | 7 | ----------------------------------- ^ ^ | | LHS RHS Notice that even though the blaster received some ACKs for its outstanding packets, since C2 is not satisfied LHS can't be moved forward which also prevents RHS from moving forward (to not violate C1). As you can see unless we implement an additional mechanism, blaster will be stuck in this position forever. This is where the coarse timeouts come into play. Whenever LHS gets stuck at a position for longer than a certain amount of time, blaster will time out and retransmit every packet in the current window that hasn't been ACKd yet. So in the previous example if LHS doesn't change for the duration of the timeout period and only packets #5 and #6 are acknowledged in the meantime, blaster will retransmit #3, #4 and #7 upon timing out. Keep in mind that some weird things can happen in this process: 1) blaster can receive an ACK for the original tranmission of a packet after retranmsitting it or 2) blaster can receive duplicate ACKs. For this project you don't need to worry about these and just keep track of whether a packet is ACKd or not. Parameters The blaster should read a text file to get parameters. Parse this file to setup your device. blaster_params.txt will contain the following line: -b -n -l -w -t -r blastee_IP: IP address of the blastee. This value has to match the IP address value in the start_mininet.py file num: Number of packets to be sent by the blaster length: Length of the variable payload part of your packet in bytes, 0 ≤ length ≤ 65535 sender_window: Size of the sender window in packets timeout: Coarse timeout value in milliseconds recv_timeout: recv_packet timeout value in milliseconds. Blaster will block on recv_packet for at most recv_timeout. This will be a pseudo-rate controller for the blaster Packet format Here is how your data packet will look like: ------------------------------------------------------------------------------------------------------------- | ETH Hdr | IP Hdr | UDP Hdr | Sequence number(32 bits) | Length(16 bits) | Variable length payload | ------------------------------------------------------------------------------------------------------------- You will need to encode the sequence number and/or length information in to your packets, which will be in raw byte format. Encoding should use big-endian format! Python has built-in library calls to achieve this with minimum pain. Printing stats Once the blaster finishes transmission (which happens upon successfully receiving an ACK for every packet it sent to the blastee -- equals to num), it is going to print some statistics about the transmission: Total TX time (in seconds): Time between the first packet sent and last packet ACKd Number of reTX: Number of retransmitted packets, this doesn't include the first transmission of a packet. Also if the same packet is retransmitted more than once, all of them will count. Number of coarse TOs: Number of coarse timeouts Throughput (Bps): You will obtain this value by dividing the total # of sent bytes(from blaster to blastee) by total TX time. This will include all the retransmissions as well! When calculating the bytes, only consider the length of the variable length payload! Goodput (Bps): You will obtain this value by dividing the total # of sent bytes(from blaster to blastee) by total TX time. However, this will NOT include the bytes sent due to retransmissions! When calculating the bytes, only consider the length of the variable length payload! Coding Your task is to implement the logic described above. The start file is named lab_6/blaster.py. ✅ In the report, show how you implement the features of blaster. "},"content/ch04/deploy.html":{"url":"content/ch04/deploy.html","title":"Task 5: Running your code","keywords":"","body":"Task 5: Running your code Testing your code Good news: you aren't going to write test cases to test your implementation. Bad news: you still need to test your code. In order to make sure that your blaster, blastee and middlebox function correctly you will have to use Mininet. The process will be explained below. Running your code Instead of running your implementations with test scenarios, you will be running the agents in Mininet. We are providing you with a topology file (start_mininet.py) in Mininet. Comments are added so please read them to understand the setup. Please do not change the addresses(IP and MAC) or node/link setup. We will be using the same topology file when testing your code (although we reserve the right to use different delay values). To spin up your agents in Mininet: Open up a terminal and type the following command. This will get Mininet started and build your topology: $ sudo python start_mininet.py Open up a xterm on each agent: mininet> xterm middlebox mininet> xterm blastee mininet> xterm blaster Start your agents: middlebox# ./switchyard/swyard.py middlebox.py blastee# ./switchyard/swyard.py blastee.py blaster# ./switchyard/swyard.py blaster.py You will need to specify some parameters for each agent when running them. To my knowledge, it is not possible to pass custom parameters to Switchyard (probably why you assumed there was a forwarding_table.txt file in your working directory in last project as well). However, this is not going to keep us from passing parameters to our agents. Just like in the previous project you will assume that there will be 3 files in your working directory: blaster_params.txt, blastee_params.txt and middlebox_params.txt. Your task is: run your code in Mininet as described above. Using different parameters to get different results and analyze them. Using Wireshark on different agent to prove that your blaster, blastee and middlebox function correctly. ✅ Write the procedure and analysis in your report with screenshots. "},"content/ch04/faq.html":{"url":"content/ch04/faq.html","title":"FAQ","keywords":"","body":"FAQ Q: How can the blaster, blastee and middlebox know the MAC and IP addresses of each other's ports? A: You will use the addresses that are specified in start_mininet.py file. You can hard code the addresses in your code. Q: Where do the .txt files, which are used to pass parameters to your agents, come from? A: You will create these .txt files with parameters of your choice. Q: How does the dropping of packets work? A: You will use the drop_rate parameter at your middlebox for deciding whether you should drop the packet or not. You can use the RNG function in Python to obtain a value (between 0 and 1) and then compare it against the drop_rate to decide what to do with the packet. Q: Are we supposed to maintain a timer for each outstanding packet? A: Coarse timeout applies to the whole sender window, therefore you don't need to maintain a separate timer for each outstanding packet. You will reset your timer whenever you move LHS. If the LHS value doesn't change for the duration of timeout then you will retransmit every non-ACKd packet in that window. Q: Can you give us an example for the coarse timeouts? A: Let's say the sender_window is 4 and the timeout is 1 second. Initially, blaster sends packets 1,2,3 and 4. Blaster receives the ACK for 2 at 300 ms into the coarse timeout (can't move LHS or RHS since packet 1 not ACKd yet). Then it receives the ACK for 1 at 500 ms. Now, blaster will move its LHS to point at 3, reset its timer (since LHS changed), send out packets 5 and 6, move RHS to 6 (RHS(6) - LHS(3) + 1 ≤ SW(4)). Even though packet 3 and 4 were sent in the previous sender window, they will not carry their timer values to the new window. Now let's say packets 4 and 5 are immediately ACKd (around ~500 ms since the initialization of the system) by the blastee and the blaster doesn't receive the ACK for packet 3 before the coarse timeout occurs. Now the system time will roughly be at 1.5 seconds(as timeout = 1 second) and since the coarse timeout occurred, blaster will retransmit packets 3 and 6. Q: Can I assume that the .txt files will have the parameters in the same order as illustrated above? A: Yes, you can safely assume that. Q: Can recv_timeout be greater than timeout? A: No, you can safely assume that recv_timeout Q: Can we send multiple packets from the blaster at each recv_timeout loop? Or do we have to send a single packet at each loop (because recv_timeout is a pseudo-rate controller)? How about the retranmissions? A: You should be sending a single packet per each recv_timeout loop. As I mentioned in the specification, recv_timeout will work as a pseudo-rate controller. Recall that you pass recv_timeout to the recv_packet function in Switchyard and this determines how long this function will block before timing out. I use the word pseudo on purpose because your blaster can receive ACKs fast enough (and without many losses) that the recv_packet call would never time out and your blaster can send packets at a faster rate. You should follow the same logic in retransmissions. Q: I'm recieving this warning upon starting a device in mininet:WARNING **: Couldn't connect to accessibility bus: Failed to connect to socket /tmp/dbus-wYnBIGP0fz: Connection refused A: You can ignore that warning, it should not disrupt the execution of your program. "},"content/ch05/lab-7.html":{"url":"content/ch05/lab-7.html","title":"Lab 7: Firewall","keywords":"","body":"Lab 7: Firewall Overview The goal for this project is to create firewall that inspects and possibly changes packet contents for packet traffic entering and exiting a network. The firewall rules we will use will be simple static rules (i.e., no \"stateful\" or dynamic rules), with one twist: we'll add the option to rate-limit certain packet flows using the token bucket algorithm. The firewall can either be created as an extension of the IPv4 router project, or as a separate device that silently inspects and possibly blocks traffic. The silent version of the firewall is described below. To integrate the firewall with the router, you would need to apply firewall rules (described below) after receiving a packet and before any forwarding decision is made. Again, the description below assumes a standalone device, but the differences between this and integrating with the router are quite minor. Below is a picture of the example network topology that is implied by the tests, and that is created by the Mininet script supplied with this project. The firewall for which you will be writing the logic is positioned at the exterior of a network to be protected (\"internal network\"), inside what is often referred to as the network DMZ. The firewall has just two interfaces, and is connected such that it will \"see\" all traffic sent from the internal network out to the rest of the internet, and it will also see any traffic coming from the rest of the internet back to the internal network. Notice that there are only two interfaces assigned to the firewall device. The basic behavior of your device is to simply forward packets from one interface to the other. You do not need to any routing logic or anything like that. The firewall logic (described below) should be applied after receiving a packet on one interface and before sending it out the other interface. It is ok in this project to assume that you will only ever have 2 network interfaces on the firewall device. Your Tasks There are three things to accomplish for this project: Implement firewalling logic based on a simple set of rules that are stored in a text file. Implement a rate-limiting capability so that certain packet flows are given limited network bandwidth. Implement a network impairment of your choice, designed to disrupt certain packet flows. Details for each of these items are given below. [!NOTE] The sentences marked with ✅ are related to the content of your report. Please pay attention. Task 1: Preparation Initiate your project with our template. Start the task here Task 2: Implement firewall rules Implement firewall rules. Start the task here Task 3: Implement the token bucket algorithm Implement the token bucket algorithm. Start the task here Task 4: Implement some other type of network impairment Implement some other type of network impairment. Start the task here Task 5: Testing Make sure that your firewall function correctly. Start the task here Handing it in Report We will provide a template of your lab assignment report here. You need to submit the report in your repository named _lab_7. The format of your report can be Microsoft Doc or PDF. An example is 123456789拾佰仟_lab_7.pdf. Submit to NJU GitLab To submit your work, you need to do the following things. Modify your code and complete your report. When you have done your work, put your report and code in the folder lab_7 then commit them. Tag the commit named which you want to submit. An example is 123456789/lab_7. Finally your project will look like switchyard ├─docs/ ├─.../ + ├─lab_7/ + │ ├─123456789拾佰仟_lab_7.pdf + │ ├─firewall.py + │ ├─firewall_rules.txt + │ ├─firewalltests.py + │ ├─www + │ │ ├─start_webserver.sh │ ├─... + │ └─start_mininet.py ├─.gitignore └─... [!WARNING] The file names in your submission have to exactly match the file names above. Otherwise, you will lose points! Submit your work by pushing your local repository to your remote repository with your tags by running the command git push origin --tags. [!WARNING] Only commit your source code to your local repository. If there are some generated files that are not source code, ignore them by adding them in the file .gitignore. "},"content/ch05/preparation.html":{"url":"content/ch05/preparation.html","title":"Task 1: Preparation","keywords":"","body":"Task 1: Preparation You can find the starter files in the directory: switchyard/examples/exercises/firewall. Let's start with it. Create a directory named lab_7 in switchyard. Copy examples/exercises/firewall/start_mininet.py to lab_7/start_mininet.py. Copy examples/exercises/firewall/firewall.py to lab_7/firewall.py. Copy examples/exercises/firewall/firewalltests.py to lab_7/firewalltests.py. Copy examples/exercises/firewall/www/start_webserver.sh to lab_7/www/start_webserver.sh. Download the rules text file firewall_rules.txt into the folder lab_7. Finally, your project will look like switchyard ├─docs/ ├─.../ + ├─lab_7/ + │ ├─123456789拾佰仟_lab_7.pdf + │ ├─firewall.py + │ ├─firewall_rules.txt + │ ├─firewalltests.py + │ ├─www + │ │ ├─start_webserver.sh │ ├─... + │ └─start_mininet.py ├─.gitignore └─... [!WARNING] All of your modifications should be done on the files under your directory lab_7. We will check and compare the git commits to judge the originality of your work. So remember to commit every time you complete one small task. "},"content/ch05/firewall-rules.html":{"url":"content/ch05/firewall-rules.html","title":"Task 2: Implement firewall rules","keywords":"","body":"Task 2: Implement firewall rules Details We will use a fairly basic syntax, with no \"stateful\" rules. All rules will be loaded from a text file named firewall_rules.txt. The syntax and semantics of the firewall rules are described in detail below. As a preview and example, however, here is a rule that denies IP traffic (with any transport protocol) with source address 10.0.0.1 and any destination address: # block any packets with source address 10.0.0.1 deny ip src 10.0.0.1 dst any (Note that the lines beginning with # are just comments.) The rules should be applied to packets just after they have been received at the firewall. The firewall should apply just to IPv4 packets (not to ARP, IPv6, or any other type of packet). In particular, non-IPv4 packets should all be permitted. As described in detail below, rules can either permit or deny packets. For packets that are permitted, they should simply be forwarded out the \"other\" interface by the firewall. For any denied packets, they should be dropped/ignored and no further processing should be done on them. Again, the syntax and meaning of the firewall rules is described below in detail. Firewall rule specification and syntax The firewall rules to be loaded by the router must be included in a text file named firewall_rules.txt. The allowable syntax for rules is as follows: [permit|deny] ip src [srcnet|any] dst [dstnet|any] [permit|deny| icmp src [srcnet|any] dst [dstnet|any] [permit|deny] [udp|tcp] src [srcnet|any] srcport [portno|any] dst [dstnet|any] dstport [portno|any] Note that items in square braces indicate items to be made concrete in a specific rule. For example, a valid rule is: permit ip src 10.0.0.1 dst any which would allow any IP packets (any protocol) with source address 10.0.0.1 and any destination address. Note that the srcnet or dstnet values may either be an exact IP address, or an IP prefix indicating a subnet of addresses. Also, portno should be specified as a single integer between 0 and 65535. any, somewhat obviously, should match anything. Here is another example: deny tcp src 1.2.3.0/24 srcport any dst any dstport 80 This rule blocks any TCP traffic with source address in the range 1.2.3.0-255, with any source TCP port, any destination IP address, and a destination port of 80. It is straightforward to access TCP and UDP port numbers using the Switchyard packet library. See the Switchyard documentation for details and examples. You may also find the IPv4Network class useful (it is built in to the ipaddress module in Python 3.4). You can instantiate an IPv4Network object by passing in a network address (with prefix) as a string. On that object, you can get the prefix length as an integer, convert the address to an integer (to be able to bitwise operations), and other useful operations. See the standard Python documentation for full details on the ipaddress module. >>> from ipaddress import IPv4Network, IPv4Address >>> net1 = IPv4Network('149.43.80.0/22') >>> net2 = IPv4Network('149.43.0.0/16') >>> net3 = IPv4Network('149.43.80.25', strict=False) >>> # for above, if you don't have a prefix at the end of an address >>> # you'll get an exception unless you say strict=False >>> # w/o a prefix length, it assumes 32 bit prefix >>> net1.prefixlen 22 >>> net2.prefixlen 16 >>> net3.prefixlen 32 >>> net1.network_address IPv4Address('149.43.80.0') >>> int(net1.network_address) 2502643712 >>> net2.network_address IPv4Address('149.43.0.0') >>> int(net2.network_address) 2502623232 >>> int(net2.network_address) & int(net3.network_address) == int(net2.network_address) True >>> # of course, the above should be true because we're basically checking >>> # whether 149.43.80.25 is contained within the network 149.43.0.0 >>> # by doing the bitwise & (AND) operation >>> Blank lines are allowed in the firewall_rules.txt file, and any line on which the first non-whitespace character is # should be ignored. Thus, you should allow Python-like comments, but you do not need to handle the situation where a comment and a rule appear on the same line --- comments will always appear separately. Rule order matters! Packets should be checked against the rules in the same order as the rules are listed in firewall_rules.txt. When a matching rule is found, the action (permit/deny) according to the rule should apply, and no more rules should be checked. If no rules match, then the default action should be to permit the packet. Note that in the example rule set below, the last rule explicitly drops all packets but your firewall should handle any reasonable rule set. Rate limits (details can be found in Task 3) can be applied to any \"permit\" rule. To specify a rate limit, the syntax is \"ratelimit [bytessec]\", included at the end of a rule. The rate limit accounting should apply to the entire packet except the Ethernet header (i.e., the packet size used for rate limit accounting should just include the IP header and beyond). Impairment (details can be found in Task 4) can be applied to any \"permit\" rule (although rate limits and impairment cannot be applied to the same rule). The only additional syntax is the inclusion of the keyword impair at the end of the rule. The project folder includes a firewall_rules.txt file. I'd recommend reading through this file to get familiar with the types of rules included in order to get a sense for how your firewall should behave. Coding Your task is to implement the logic described above. The start file is named lab_7/firewall.py. ✅ In the report, show how you implement the firewall rules. "},"content/ch05/token-bucket.html":{"url":"content/ch05/token-bucket.html","title":"Task 3: Implement the token bucket algorithm","keywords":"","body":"Task 3: Implement the token bucket algorithm Details Rules that permit traffic may optionally have rate limits specified, in bytes per second. Here is the same example rule from above, but with a rate limit specified as 1000 bytes per second: # allow, but rate-limit packets with src 10.0.0.1 # destined to any address in the prefix 192.168.0.0/16 # with limit as 1250 bytes/sec (10 kbit/s) permit ip src 10.0.0.1 dst 192.168.0.0/16 ratelimit 1000 When implementing the token bucket algorithm, you should do the following: Tokens should be semantically equated to some number of bytes allowed. Thus, if there are 100 tokens in the bucket, you should allow 100 bytes to be forwarded. Tokens should be added to the bucket every 0.5 seconds. If the rate limit configured is r bytes per second, exactly r/2 tokens should be added to the bucket every 0.5 seconds. For the example above, you would add 500 tokens to the bucket every 0.5 seconds. [!NOTE] from your experience in operating systems, you should know (or at least suspect) that OS timers are a wee bit fickle. Just be aware of this fact and devise your code so that it doesn't assume a perfect timer, because a perfect timer doesn't exist. Remember that in the net.recv_packet() call, there's a timeout value you can give in order not to block on the call. In order to ensure you update the token bucket every 0.5 seconds, just manipulate the timeout value. You may even wish to update the token bucket more often than 0.5 seconds; that's fine as long as you only add r/2 tokens every 0.5 seconds. The maximum number of tokens in the bucket is 2*r, where r is the configured rate limit in bytes/second. The minimum number of tokens in the bucket should be 0 (zero). When a packet arrives that matches a rule with a rate limit configured, you should (a) determine the size of the packet in bytes, including everything from the IP header onward (i.e., include everything except the Ethernet header), (b) check whether the packet size is less than or equal to the number of tokens. If it is, subtract that number of tokens and allow the packet. Otherwise, the packet should be dropped. To compute the packet size in bytes, you can get the size of the entire packet by saying len(packet) (assuming the variable packet is an instance of a Packet), then subtract the size of the Ethernet header (len(packet.get_header(Ethernet))). Note that the last expression assumes that the Ethernet header actually exists in the packet, but this should normally be the case. Note that with this algorithm, if the rate limit is set too low, you may never allow any packets at all (e.g., if you set the limit to 15 bytes/sec, you'd never allow any TCP traffic since the smallest TCP packet is 40 bytes, which is greater than 2*15). Also note that the rate limit you achieve is not expected to be exactly the specified rate limit. Coding Your task is to implement the logic described above. The start file is named lab_7/firewall.py. ✅ In the report, show how you implement the token bucket algorithm. "},"content/ch05/impairment.html":{"url":"content/ch05/impairment.html","title":"Task 4: Implement some other type of network impairment","keywords":"","body":"Task 4: Implement some other type of network impairment Details Rules that permit traffic may specify that the traffic flow should be impaired in some way. A rule that specifies that traffic should be impaired should simply have the keyword impair as the last item in a rule. For example: # allow, but degrade the service given to packets # from source 10.0.0.1 destined to any host in # 192.168.0.0/16. permit ip src 10.0.0.1 dst 192.168.0.0/16 impair You can choose exactly how flows should be impaired. Here are some fun options: Randomly drop some fraction of the packets belonging to the flow. Rewrite/overwrite the TCP advertised window to make it smaller. Rewrite/overwrite the application payload contents of packets. Randomly inject TCP RST packets to reset (and take down) traffic flows. Lastly, note that a given permit rule may specify a rate limit, that impairment should be applied, or that the traffic should simply be permitted. A rule may not specify both a rate limit and impairment. Coding Your task is to implement the logic described above. The start file is named lab_7/firewall.py. ✅ In the report, show how you implement the impairment. "},"content/ch05/testing.html":{"url":"content/ch05/testing.html","title":"Task 5: Testing","keywords":"","body":"Task 5: Testing Testing your code There is a Switchyard test script available for basic firewalling capabilities (i.e., permit and deny rules without any rate limits or impairment). The source code for this test scenario is available in the project repo as firewalltests.py. The test source is given since you may find it helpful to add new tests or modify existing tests as you develop your code. As usual, you can test your code using a command line like: $ swyard -t firewalltests.py firewall.py There are minimal automated tests for the rate limitation features, and there are no automated tests for your impairment \"feature\". The minimal rate limitation tests just check whether at least one packet is permitted by your firewall: these should all definitely pass. There are no sophisticated tests for checking whether you impose the right rate limit on a flow. To do that, you can use Mininet as described below. ✅ In the report, show the test result. To test your impairment feature, you can either construct a Switchyard test (or set of tests) or test your impairment feature in Mininet (somehow).(Optional) There is a file impairmenttest.py in the project directory that you can modify for testing your impairment feature with Switchyard if you wish. There is some Switchyard documentation available to describe the meaning of various API calls in test scenario creation. To try your firewall in Mininet, you can do the following: $ sudo python start_mininet.py Once Mininet is started, open an xterm on the node named \"firewall\", and then start the firewall: mininet> xterm firewall and on the firewall node: firewall# swyard firewall.py There are two other hosts in the Mininet setup: one named \"internal\" and another named \"external\". Testing rate limitation in Mininet To test rule 13 (permit icmp src any dst any ratelimit 150), you can use the following ping command within Mininet: mininet> internal ping -c10 -s72 192.168.0.2 This command will cause the \"internal\" host to send an ICMP echo request (ping) to the \"external\" host, through the firewall device. There will be 10 echo request packets sent, once per second, and the size of each packet (from IP header through the end of the packet) will be 20 bytes (IP) + 8 bytes (ICMP header) + 72 bytes (the -s72 flag) of \"data\", resulting in a 100 byte packet. The echo reply will also be exactly 100 bytes. The \"steady-state\" effect of this ping command line and the rate limitation should be that every other ICMP echo request should be allowed. (Think about why this is the case. You'll likely allow the first couple echo request/replies, but then the every-other regime should take hold.) There are two other rate limitation rules: rules 7 and 8 (replicated below): # rule 7 permit tcp src 192.168.0.0/16 srcport any dst any dstport 80 ratelimit 12500 # rule 8 permit tcp src any srcport 80 dst 192.168.0.0/16 dstport any ratelimit 12500 To test these rules you can generate some HTTP traffic over port 80 using some simple command-line tools. Note that these rules apply separate rate limits to each direction of the TCP connection and that the limit is equivalent to 100Kbits/sec. To generate HTTP/port 80 traffic to exercise these limits, do the following. On the host \"external\", start a server: mininet> external ./www/start_webserver.sh Besides starting up a simple Python-based webserver, this script creates a file (called \"bigfile\", although it's actually pretty small) to transfer so that we can exercise the rate limit. Now, on the internal host, make a request using the program wget: mininet> internal wget http://192.168.0.2/bigfile -O /dev/null (The -O /dev/null command-line parameter just says to save the response in /dev/null, which is just a virtual wastebasket for bits.) One other note regarding rate-limit testing: you shouldn't expect the rate limitation to work especially well in Mininet. Your mileage may vary, but don't be surprised if you get very poor throughput with the firewall (and much less than the specified rate limit). Your task is: test rate limitation in Mininet as described above. ✅ Write the procedure and analysis in your report with screenshots. Testing impairments in Mininet Testing your impairment capability depends on what you implemented. One way to generate traffic (at least TCP traffic) for testing the impairment is to use the http server used for testing rate limits. The rules for the impairment is as follows (see also firewall_rules.txt): # rule 11 permit tcp src 192.168.0.0/24 srcport any dst any dstport 8000 impair # rule 12 permit tcp src any srcport 8000 dst 192.168.0.0/24 dstport any impair To start the webserver so that it listens on port 8000 (which is the port specified in the impair rule), you can say: mininet> external ./www/start_webserver.sh 8000 To generate traffic from internal to trigger the impair rule, you can use the wget program again: mininet> internal wget http://192.168.0.2:8000/filename The filename you use can either be \"bigfile\" (i.e., the same file used in the rate limit tests) or it can be any file you construct. If your impairment depends on certain application payload contents (e.g., you search packets to see whether the string \"sneaky crackers\" is present) you can craft files that have the desired contents. If you save them in the www folder (directly within the project repo folder) you can use the wget program as above to request those files and trigger your impairment. Your task is: test impairments in Mininet as described above. ✅ Write the procedure and analysis in your report with screenshots. "},"appendix/appendix.html":{"url":"appendix/appendix.html","title":"Appendix","keywords":"","body":"Appendix Some notes and additional materials are in this chapter. "},"appendix/environment-setup.html":{"url":"appendix/environment-setup.html","title":"Environment Setup","keywords":"","body":"Environment Setup If you see here then you must be a high-end player, the instructions here will be very simple. Install Switchyard You can find instructions here, the repository of switchyard on GitHub. A quick note here for Ubuntu. git clone https://gitee.com/shellqiqi/switchyard.git sudo apt-get install libffi-dev libpcap-dev python3-dev python3-pip You can install Switchyard and the necessary related packages in an isolated Python virtual environment (\"venv\"), which is the recommended path, or in the system directories, which is often less desirable. The venv route is highly suggested, since it makes all installation \"local\" and can easily destroyed, cleaned up, and recreated. To create a new virtual environment, you could do something like the following under your workspace folder python3 -m venv syenv You can change the name syenv to whatever you'd like to name your virtual environment. Next, you need to activate the environment. The instructions vary depending on the shell you're using. On bash, the command is source ./syenv/bin/activate You'll need to replace syenv with whatever you named the virtual environment. If you're using a different shell than bash, refer to Python documentation on the venv module. Finally, install Switchyard. All the required additional libraries should be automatically installed, too. python3 -m pip install switchyard Then I suggest to exclude your virtual environment out of git tracking. Add this line in .gitignore syenv/ Install Mininet sudo apt-get install mininet Or you want to build mininet yourself. The installation guide is here. Install Wireshark sudo add-apt-repository ppa:wireshark-dev/stable sudo apt-get update sudo apt-get install wireshark You need to configure wireshark during installation. For non-superusers capturing packets, choose Yes here. Then add your user to wireshark user group to allow you capturing packets. sudo usermod -a -G wireshark $USER Other Softwares You also want to install some editors like Vim, Emacs, Visual Studio Code, Sublime and so on. But we do not install any one of them to avoiding a quarrel about the best editor. Choose your favorite one and install it yourself. Another helpful module VBoxGuestAdditions is not installed because various virtual machine hypervisors you will use. "},"appendix/about-this-repository.html":{"url":"appendix/about-this-repository.html","title":"About This Repository","keywords":"","body":"About This Repository This repository is the source code of our manual. Building You need to install gitbook-cli first. Install yarn https://classic.yarnpkg.com/en/docs/install#debian-stable Install gitbook-cli using yarn yarn global add gitbook-cli When you build this for the first time, you need to install plugins. gitbook install Then run gitbook build . docs If you want to preview, run the command below. The local website is http://localhost:4000. gitbook serve License The manual is distributed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. Repository Structure The body is placed under the content folder, and the chapters are placed in the corresponding chapter folder, starting with ch and followed by two-digit numbers. Each section and subsection is placed in the chapter folder. The pictures and other content used in the text are placed in the assets folder in the corresponding chapter folder. "}}